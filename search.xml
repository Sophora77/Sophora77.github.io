<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数组的操作方法合集(1)</title>
    <url>/2021/09/10/flex%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h2 id="创建一个数组"><a href="#创建一个数组" class="headerlink" title="创建一个数组"></a>创建一个数组</h2><div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字面量方式:</span></span><br><span class="line"><span class="comment">// 这个方法也是我们最常用的，在初始化数组的时候 相当方便</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>];  <span class="comment">// [3,11,8];</span></span><br><span class="line"><span class="comment">// 构造器:</span></span><br><span class="line"><span class="comment">// 实际上 new Array === Array,加不加new 一点影响都没有。</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="title class_">Array</span>(); <span class="comment">// [] </span></span><br><span class="line"><span class="keyword">var</span> a = <span class="title class_">Array</span>(<span class="number">3</span>); <span class="comment">// [,,] </span></span><br><span class="line"><span class="keyword">var</span> a = <span class="title class_">Array</span>(<span class="number">3</span>,<span class="number">11</span>,<span class="number">8</span>); <span class="comment">// [ 3,11,8 ]</span></span><br></pre></td></tr></table></figure></div>

<ol>
<li><strong>ES6 Array.of() 返回由所有参数值组成的数组</strong></li>
</ol>
<p>定义：返回由所有参数值组成的数组，如果没有参数，就返回一个空数组。</p>
<p>目的：Array.of() 出现的目的是为了解决上述构造器因参数个数不同，导致的行为有差异的问题</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>); <span class="comment">// [3,11,8]</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">3</span>); <span class="comment">// [3]</span></span><br></pre></td></tr></table></figure></div>

<ol>
<li><strong>ES6 Arrary.from() 将两类对象转为真正的数组</strong></li>
</ol>
<p>定义：用于将两类对象转为真正的数组（不改变原对象，返回新的数组）。</p>
<p>参数：</p>
<p>第一个参数(必需):要转化为真正数组的对象。</p>
<p>第二个参数(可选): 类似数组的map方法，对每个元素进行处理，将处理后的值放入返回的数组。</p>
<p>第三个参数(可选): 用来绑定this。</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 对象拥有length属性</span></span><br><span class="line">    <span class="keyword">let</span> obj = &#123;<span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>:<span class="string">&#x27;c&#x27;</span>, <span class="attr">length</span>: <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> arr = <span class="title class_">Array</span>.<span class="title function_">from</span>(obj); <span class="comment">// [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;];</span></span><br><span class="line">    <span class="comment">// 2. 部署了 Iterator接口的数据结构 比如:字符串、Set、NodeList对象</span></span><br><span class="line">    <span class="keyword">let</span> arr = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="string">&#x27;hello&#x27;</span>); <span class="comment">// [&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;]</span></span><br><span class="line">    <span class="keyword">let</span> arr = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>])); <span class="comment">// [&#x27;a&#x27;,&#x27;b&#x27;]</span></span><br></pre></td></tr></table></figure></div>

<h2 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h2><p>数组原型提供了非常多的方法，这里分为三类来讲，一类会改变原数组的值，一类是不会改变原数组，以及数组的遍历方法。</p>
<h3 id="改变原数组的方法-9个"><a href="#改变原数组的方法-9个" class="headerlink" title="改变原数组的方法(9个):"></a><strong>改变原数组的方法(9个):</strong></h3><div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">    <span class="title class_">ES5</span>:</span><br><span class="line">     a.<span class="title function_">splice</span>()/ a.<span class="title function_">sort</span>() / a.<span class="title function_">pop</span>()/ a.<span class="title function_">shift</span>()/  a.<span class="title function_">push</span>()/ a.<span class="title function_">unshift</span>()/ a.<span class="title function_">reverse</span>()</span><br><span class="line">    <span class="title class_">ES6</span>:</span><br><span class="line">    a.<span class="title function_">copyWithin</span>() / a.<span class="property">fill</span></span><br></pre></td></tr></table></figure></div>

<p>对于这些能够改变原数组的方法，要注意避免在循环遍历中改变原数组的选项，比如: 改变数组的长度，导致遍历的长度出现问题</p>
<h4 id="splice-添加-x2F-删除数组元素"><a href="#splice-添加-x2F-删除数组元素" class="headerlink" title="splice() 添加&#x2F;删除数组元素"></a><strong>splice() 添加&#x2F;删除数组元素</strong></h4><p>定义： splice() 方法<strong>向&#x2F;从数组中添加&#x2F;删除</strong>项目，然后返回被删除的项目</p>
<p>语法： <code>array.splice(index,howmany,item1,.....,itemX)</code></p>
<p>参数:</p>
<ul>
<li>index：必需。整数，规定添加&#x2F;删除项目的位置，使用负数可从数组结尾处规定位置。</li>
<li>howmany：可选。要删除的项目数量。如果设置为 0，则不会删除项目。</li>
<li>item1, …, itemX： 可选。向数组添加的新项目。</li>
</ul>
<p>返回值: 如果有元素被删除,返回包含被删除项目的新数组。</p>
<p>注意点：</p>
<ol>
<li>数组如果元素不够，会删除到最后一个元素为止</li>
<li>操作的元素，包括开始的那个元素</li>
<li>可以添加很多个元素</li>
<li>添加是在开始的元素前面添加的</li>
</ol>
<h4 id="sort-数组排序"><a href="#sort-数组排序" class="headerlink" title="sort() 数组排序"></a><strong>sort() 数组排序</strong></h4><p>定义: sort()方法对数组元素进行排序，并返回这个数组。</p>
<p>参数可选: 规定排序顺序的比较函数。</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串排列 看起来很正常</span></span><br><span class="line">    <span class="keyword">var</span> a = [<span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Mango&quot;</span>];</span><br><span class="line">    a.<span class="title function_">sort</span>(); <span class="comment">// [&quot;Apple&quot;,&quot;Banana&quot;,&quot;Mango&quot;,&quot;Orange&quot;]</span></span><br><span class="line">    <span class="comment">// 数字排序的时候 因为转换成Unicode字符串之后，有些数字会比较大会排在后面 这显然不是我们想要的</span></span><br><span class="line">    <span class="keyword">var</span>	a = [<span class="number">10</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">20</span>,<span class="number">25</span>,<span class="number">8</span>];</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">sort</span>()) <span class="comment">// [1,10,20,25,3,8];</span></span><br></pre></td></tr></table></figure></div>

<ol>
<li><p><strong>比较函数的两个参数：</strong></p>
<p>sort的比较函数有两个默认参数，要在函数中接收这两个参数，这两个参数是数组中两个要比较的元素，通常我们用 a 和 b 接收两个将要比较的元素：</p>
</li>
</ol>
<ul>
<li>若比较函数返回值&lt;0，那么a将排到b的前面;</li>
<li>若比较函数返回值&#x3D;0，那么a 和 b 相对位置不变；</li>
<li>若比较函数返回值&gt;0，那么b 排在a 将的前面；</li>
</ul>
<ol>
<li><p><strong>sort排序常见用法:</strong></p>
<ol>
<li>数组元素为数字的升序、降序:</li>
</ol>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array =  [<span class="number">10</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>,<span class="number">20</span>,<span class="number">4</span>,<span class="number">25</span>,<span class="number">8</span>];</span><br><span class="line"> <span class="comment">// 升序 a-b &lt; 0   a将排到b的前面，按照a的大小来排序的 </span></span><br><span class="line"> <span class="comment">// 比如被减数a是10，减数是20  10-20 &lt; 0   被减数a(10)在减数b(20)前面   </span></span><br><span class="line"> array.<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> a-b;</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(array); <span class="comment">// [1,3,4,4,8,10,20,25];</span></span><br><span class="line"> <span class="comment">// 降序 被减数和减数调换了  20-10&gt;0 被减数b(20)在减数a(10)的前面</span></span><br><span class="line"> array.<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> b-a;</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(array); <span class="comment">// [25,20,10,8,4,4,3,1];</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<p>b. 数组多条件排序</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [&#123;<span class="attr">id</span>:<span class="number">10</span>,<span class="attr">age</span>:<span class="number">2</span>&#125;,&#123;<span class="attr">id</span>:<span class="number">5</span>,<span class="attr">age</span>:<span class="number">4</span>&#125;,&#123;<span class="attr">id</span>:<span class="number">6</span>,<span class="attr">age</span>:<span class="number">10</span>&#125;,&#123;<span class="attr">id</span>:<span class="number">9</span>,<span class="attr">age</span>:<span class="number">6</span>&#125;,&#123;<span class="attr">id</span>:<span class="number">2</span>,<span class="attr">age</span>:<span class="number">8</span>&#125;,&#123;<span class="attr">id</span>:<span class="number">10</span>,<span class="attr">age</span>:<span class="number">9</span>&#125;];</span><br><span class="line">     array.<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">         <span class="keyword">if</span>(a.<span class="property">id</span> === b.<span class="property">id</span>)&#123;<span class="comment">// 如果id的值相等，按照age的值降序</span></span><br><span class="line">             <span class="keyword">return</span> b.<span class="property">age</span> - a.<span class="property">age</span></span><br><span class="line">         &#125;<span class="keyword">else</span>&#123; <span class="comment">// 如果id的值不相等，按照id的值升序</span></span><br><span class="line">             <span class="keyword">return</span> a.<span class="property">id</span> - b.<span class="property">id</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;)</span><br><span class="line">  <span class="comment">// [&#123;&quot;id&quot;:2,&quot;age&quot;:8&#125;,&#123;&quot;id&quot;:5,&quot;age&quot;:4&#125;,&#123;&quot;id&quot;:6,&quot;age&quot;:10&#125;,&#123;&quot;id&quot;:9,&quot;age&quot;:6&#125;,&#123;&quot;id&quot;:10,&quot;age&quot;:9&#125;,&#123;&quot;id&quot;:10,&quot;age&quot;:2&#125;]</span></span><br></pre></td></tr></table></figure></div>

<p>c. 自定义比较函数,<strong>运用好返回值，我们可以写出任意符合自己需求的比较函数</strong></p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [&#123;<span class="attr">name</span>:<span class="string">&#x27;Koro1&#x27;</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">&#x27;Koro1&#x27;</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">&#x27;OB&#x27;</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">&#x27;Koro1&#x27;</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">&#x27;OB&#x27;</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">&#x27;OB&#x27;</span>&#125;];</span><br><span class="line">    array.<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.<span class="property">name</span> === <span class="string">&#x27;Koro1&#x27;</span>)&#123;<span class="comment">// 如果name是&#x27;Koro1&#x27; 返回-1 ，-1&lt;0 a排在b的前面</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">// 如果不是的话，a排在b的后面</span></span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// [&#123;&quot;name&quot;:&quot;Koro1&quot;&#125;,&#123;&quot;name&quot;:&quot;Koro1&quot;&#125;,&#123;&quot;name&quot;:&quot;Koro1&quot;&#125;,&#123;&quot;name&quot;:&quot;OB&quot;&#125;,&#123;&quot;name&quot;:&quot;OB&quot;&#125;,&#123;&quot;name&quot;:&quot;OB&quot;&#125;]</span></span><br></pre></td></tr></table></figure></div>

<h4 id="pop-删除一个数组中的最后的一个元素"><a href="#pop-删除一个数组中的最后的一个元素" class="headerlink" title="pop() 删除一个数组中的最后的一个元素"></a><strong>pop() 删除一个数组中的最后的一个元素</strong></h4><p>定义: pop() 方法删除一个数组中的最后的一个元素，并且返回这个元素。</p>
<p>参数: 无。</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span>  a =  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> item = a.<span class="title function_">pop</span>();  <span class="comment">// 3</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// [1,2]</span></span><br></pre></td></tr></table></figure></div>

<h4 id="shift-删除数组的第一个元素"><a href="#shift-删除数组的第一个元素" class="headerlink" title="shift() 删除数组的第一个元素"></a><strong>shift() 删除数组的第一个元素</strong></h4><p>定义: shift()方法删除数组的第一个元素，并返回这个元素。</p>
<p>参数: 无。</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span>  a =  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.<span class="title function_">shift</span>();  <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// [2,3]</span></span><br></pre></td></tr></table></figure></div>

<h4 id="push-向数组的末尾添加元素"><a href="#push-向数组的末尾添加元素" class="headerlink" title="push() 向数组的末尾添加元素"></a><strong>push() 向数组的末尾添加元素</strong></h4><p>定义：push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。</p>
<p>参数: item1, item2, …, itemX ,要添加到数组末尾的元素</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span>  a =  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.<span class="title function_">push</span>(<span class="string">&#x27;末尾&#x27;</span>);  <span class="comment">// 4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// [1,2,3,&#x27;末尾&#x27;]</span></span><br></pre></td></tr></table></figure></div>

<h4 id="unshift-向数组的开头添加元素"><a href="#unshift-向数组的开头添加元素" class="headerlink" title="unshift() 向数组的开头添加元素"></a><strong>unshift() 向数组的开头添加元素</strong></h4><p>定义：unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。</p>
<p>参数: item1, item2, …, itemX ,要添加到数组开头的元素</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span>  a =  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.<span class="title function_">unshift</span>(<span class="string">&#x27;开头&#x27;</span>);  <span class="comment">// 4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// [&#x27;开头&#x27;,1,2,3]</span></span><br></pre></td></tr></table></figure></div>

<h4 id="reverse-颠倒数组中元素的顺序"><a href="#reverse-颠倒数组中元素的顺序" class="headerlink" title="reverse() 颠倒数组中元素的顺序"></a><strong>reverse() 颠倒数组中元素的顺序</strong></h4><p>定义: reverse() 方法用于颠倒数组中元素的顺序。</p>
<p>参数: 无</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span>  a =  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">    a.<span class="title function_">reverse</span>();  </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// [3,2,1]</span></span><br></pre></td></tr></table></figure></div>

<h4 id="ES6-copyWithin-指定位置的成员复制到其他位置"><a href="#ES6-copyWithin-指定位置的成员复制到其他位置" class="headerlink" title="ES6: copyWithin() 指定位置的成员复制到其他位置"></a><strong>ES6: copyWithin() 指定位置的成员复制到其他位置</strong></h4><p>定义: 在当前数组内部，将指定位置的成员复制到其他位置,并返回这个数组。</p>
<p>语法:</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">copyWithin</span>(target, start = <span class="number">0</span>, end = <span class="variable language_">this</span>.<span class="property">length</span>)</span><br></pre></td></tr></table></figure></div>

<p>参数:</p>
<p>三个参数都是数值，如果不是，会自动转为数值.</p>
<ol>
<li>target（必需）：从该位置开始替换数据。如果为负值，表示倒数。</li>
<li>start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。</li>
<li>end（可选）：到该位置前停止读取数据，默认等于数组长度。使用负数可从数组结尾处规定位置。</li>
</ol>
<p>浏览器兼容(MDN): chrome 45,Edge 12,Firefox32,Opera 32,Safari 9, IE 不支持</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -2相当于3号位，-1相当于4号位</span></span><br><span class="line">        [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].<span class="title function_">copyWithin</span>(<span class="number">0</span>, -<span class="number">2</span>, -<span class="number">1</span>)</span><br><span class="line">        <span class="comment">// [4, 2, 3, 4, 5]</span></span><br><span class="line">        <span class="keyword">var</span> a=[<span class="string">&#x27;OB1&#x27;</span>,<span class="string">&#x27;Koro1&#x27;</span>,<span class="string">&#x27;OB2&#x27;</span>,<span class="string">&#x27;Koro2&#x27;</span>,<span class="string">&#x27;OB3&#x27;</span>,<span class="string">&#x27;Koro3&#x27;</span>,<span class="string">&#x27;OB4&#x27;</span>,<span class="string">&#x27;Koro4&#x27;</span>,<span class="string">&#x27;OB5&#x27;</span>,<span class="string">&#x27;Koro5&#x27;</span>]</span><br><span class="line">        <span class="comment">// 2位置开始被替换,3位置开始读取要替换的 5位置前面停止替换</span></span><br><span class="line">        a.<span class="title function_">copyWithin</span>(<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line">        <span class="comment">// [&quot;OB1&quot;,&quot;Koro1&quot;,&quot;Koro2&quot;,&quot;OB3&quot;,&quot;OB3&quot;,&quot;Koro3&quot;,&quot;OB4&quot;,&quot;Koro4&quot;,&quot;OB5&quot;,&quot;Koro5&quot;]</span></span><br></pre></td></tr></table></figure></div>

<p>从上述栗子:</p>
<ol>
<li>第一个参数是开始被替换的元素位置</li>
<li>要替换数据的位置范围:从第二个参数是开始读取的元素，在第三个参数前面一个元素停止读取</li>
<li>数组的长度不会改变</li>
<li><strong>读了几个元素就从开始被替换的地方替换几个元素</strong></li>
</ol>
<h4 id="ES6-fill-填充数组"><a href="#ES6-fill-填充数组" class="headerlink" title="ES6: fill() 填充数组"></a><strong>ES6: fill() 填充数组</strong></h4><p>定义: 使用给定值，填充一个数组。</p>
<p>参数:</p>
<p>第一个元素(必须): 要填充数组的值</p>
<p>第二个元素(可选): 填充的开始位置,默认值为0</p>
<p>第三个元素(可选)：填充的结束位置，默认是为<code>this.length</code></p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>].<span class="title function_">fill</span>(<span class="number">7</span>)</span><br><span class="line">    <span class="comment">// [7, 7, 7]</span></span><br><span class="line">    [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>].<span class="title function_">fill</span>(<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="comment">// [&#x27;a&#x27;, 7, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure></div>

]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>有关DOM节点</title>
    <url>/2020/11/17/DOM%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="DOM节点"><a href="#DOM节点" class="headerlink" title="DOM节点"></a>DOM节点</h1><p>网页中的所有内容都是节点（标签、属性、文本、注释等）</p>
<p><img lazyload src="/images/loading.svg" data-src="/../img/image-20230212201857603.png" alt="image-20230212201857603.png"></p>
<p>节点一般分为下面3类：</p>
<ul>
<li>元素节点：例如   div标签</li>
<li>属性节点：例如  class属性</li>
<li>文本节点：例如  文字、空格、换行等</li>
</ul>
<p>节点的层级：</p>
<ul>
<li>根节点：<html>，有且只能有一个</html></li>
<li>父节点：某个节点的上一级节点</li>
<li>子节点：某个节点的下一级节点</li>
<li>兄弟节点：拥有同一个父节点的节点</li>
</ul>
<p>这里重点学习元素节点，可以更好的让我们搞清楚标签元素之间的关系</p>
<h3 id="1-父节点"><a href="#1-父节点" class="headerlink" title="1.父节点"></a>1.父节点</h3><p>父节点查找：</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line">子元素.<span class="property">parentNode</span></span><br></pre></td></tr></table></figure></div>

<p>返回最近一级的父节点，找不到则返回null</p>
<h3 id="2-子节点"><a href="#2-子节点" class="headerlink" title="2.子节点"></a>2.子节点</h3><p>子节点查找：</p>
<p>2.1 childNodes：</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line">父元素.<span class="property">childNodes</span></span><br></pre></td></tr></table></figure></div>

<p>获得的是当前元素的所有子节点的集合</p>
<p>2.2 children属性：</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line">父元素.<span class="property">children</span></span><br></pre></td></tr></table></figure></div>

<p>只返回子元素节点（不返回属性节点、文本节点）</p>
<p>返回的是一个伪数组</p>
<p>2.3 返回第一个子节点</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line">元素名.<span class="property">firstChild</span></span><br></pre></td></tr></table></figure></div>

<p>2.4 返回最后一个子节点</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line">元素名.<span class="property">lastChild</span></span><br></pre></td></tr></table></figure></div>

<p>2.5 第一个子元素节点（不包含文本节点、属性节点）</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line">元素名.<span class="property">firstElementChild</span></span><br></pre></td></tr></table></figure></div>

<p>2.6 最后一个子元素节点（不包含文本节点、属性节点）</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line">元素名 . lsstElementChild</span><br></pre></td></tr></table></figure></div>

<h3 id="3-兄弟节点"><a href="#3-兄弟节点" class="headerlink" title="3.兄弟节点"></a>3.兄弟节点</h3><p>兄弟关系查找</p>
<p>3.1 获取下一个兄弟节点（包含元素节点、文本节点、属性节点）</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line">元素名 . nextSibling</span><br></pre></td></tr></table></figure></div>

<p>3.2 获取上一个兄弟节点（包含元素节点、文本节点、属性节点）</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line">元素名 . previousSibling</span><br></pre></td></tr></table></figure></div>

<p>3.3 下一个兄弟节点</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line">元素.<span class="property">nextElementSibling</span></span><br></pre></td></tr></table></figure></div>

<p>3.4 上一个兄弟节点</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line">元素.<span class="property">previousElementSibling</span></span><br></pre></td></tr></table></figure></div>

<h3 id="4-创建一个新的网页元素，再添加到网页内"><a href="#4-创建一个新的网页元素，再添加到网页内" class="headerlink" title="4.创建一个新的网页元素，再添加到网页内"></a>4.创建一个新的网页元素，再添加到网页内</h3><p>1.创建一个新的元素节点</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;标签名&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p>2.插入到某个父元素中&#x2F;添加节点</p>
<p>插入到父元素的最后一个子元素：</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line">父元素.<span class="title function_">appendChild</span>(要插入的元素)</span><br></pre></td></tr></table></figure></div>

<p>插入到父元素中某个子元素的前面</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line">父元素.<span class="title function_">insertBefore</span>(插入的元素, 放到哪个元素的前面)</span><br></pre></td></tr></table></figure></div>

<h3 id="5-赋节点"><a href="#5-赋节点" class="headerlink" title="5.赋节点"></a>5.赋节点</h3><p>克隆一个已经有的元素节点</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line">元素.<span class="title function_">cloneNode</span>(布尔值）</span><br></pre></td></tr></table></figure></div>

<p>布尔值为true，深拷贝，代表克隆是会包含后代节点一起克隆</p>
<p>布尔值为false，浅拷贝，代表克隆是不包含后代节点，默认为false</p>
<h3 id="6-删除节点"><a href="#6-删除节点" class="headerlink" title="6.删除节点"></a>6.删除节点</h3><p>在JavaScript原生DOM中，要删除元素必须通过父元素删除</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line">父元素.<span class="property">removeChild</span>（要删除的元素）</span><br></pre></td></tr></table></figure></div>

<p>这里要注意，如果不存在父子关系，删除则不成功</p>
<p>删除节点和隐藏节点（display：none）是有区别的：</p>
<p>隐藏的节点还存在，删除节点是直接从html中删除节点</p>
]]></content>
      <tags>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中的数据类型</title>
    <url>/2020/07/20/js%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="一、JS中有哪些数据类型"><a href="#一、JS中有哪些数据类型" class="headerlink" title="一、JS中有哪些数据类型"></a>一、JS中有哪些数据类型</h2><p>JS中的数据类型大致分为<strong>基本数据类型</strong>和引用类型</p>
<p><strong>基本数据类型有</strong>：</p>
<ul>
<li>String (字符串）</li>
<li>Number（数字）</li>
<li>Boolean （布尔值）</li>
<li>Undefined （未定义）</li>
<li>null （空值）</li>
<li>Symbol （符号）</li>
<li>Bigint</li>
</ul>
<ol>
<li>其中 <code>string</code> 、<code>number</code> 、<code>boolean</code> 和 <code>null</code> <code>undefined</code> 这五种类型统称为<strong>原始类型</strong>（Primitive），表示不能再细分下去的基本类型;</li>
<li><code>symbol</code>是ES6中新增的数据类型，<code>symbol</code> 表示独一无二的值，最大的用法是用来定义对象的唯一属性名</li>
<li>基本数据类型的值存放在栈中，在栈中存放的是对应的值，赋值时直接赋对应的值</li>
</ol>
<p><strong>引用类型有：</strong>Object 、 Array 、 Function、Data等</p>
<p>引用数据类型的值存放在堆中，在栈中存放的是指向堆内存的地址，赋值时赋的是指向堆内存的地址</p>
<h2 id="二、JS是弱类型语言的理解"><a href="#二、JS是弱类型语言的理解" class="headerlink" title="二、JS是弱类型语言的理解"></a>二、JS是弱类型语言的理解</h2><p>js声明变量的时候并没有预先确定的类型，变量的类型就是这个值的类型，就是说<strong>变量当前的类型由其值所决定</strong>，夸张一点说就是上一秒还是字符串，下一秒可能就是数字类型了，其中可能发生了什么操作进行强制转换了。所以说弱类型的这种<strong>不需要预先确定的类型</strong>的特性能给我们带来便利，也会带来困扰。</p>
<blockquote>
<p><code>javascript</code>中强制类型转换是一个非常易出现<code>bug</code>的点，知道强制转换时候的规则吗？</p>
</blockquote>
<ol>
<li>用<code>ToPrimitive</code>(转换为原始值)，可以把引用类型转换为原始类型</li>
<li>可以接收两个参数</li>
</ol>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line">**</span><br><span class="line">* @obj 需要转换的对象</span><br><span class="line">* @type 期望转换为的原始数据类型，可选</span><br><span class="line">*/</span><br><span class="line"><span class="title class_">ToPrimitive</span>(obj,type)  </span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li><code>Number</code>运算符转换规则：</li>
</ol>
<ul>
<li><p><code>null</code> 转换为 0</p>
</li>
<li><p><code>undefined</code> 转换为 <code>NaN</code></p>
</li>
<li><p><code>true</code> 转换为 1，<code>false</code> 转换为 0</p>
</li>
<li><p>字符串转换时遵循数字常量规则，转换失败返回 <code>NaN</code></p>
</li>
</ul>
<ol start="4">
<li><code>String</code>运算符转换规则:</li>
</ol>
<ul>
<li><p><code>null</code> 转换为 <code>&#39;null&#39;</code></p>
</li>
<li><p><code>undefined</code> 转换为  <code>&#39;undefined&#39;</code></p>
</li>
<li><p><code>true</code> 转换为 <code>&#39;true&#39;</code>，<code>false</code> 转换为 <code>&#39;false&#39;</code></p>
</li>
<li><p>数字转换遵循通用规则，极大极小的数字使用指数形</p>
</li>
</ul>
<ol start="5">
<li><code>ToBoolean</code>运算符转换规则:</li>
</ol>
<p>​	除了下述 6 个值转换结果为 <code>false</code>，其他全部为 <code>true</code>：</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="literal">undefined</span></span><br><span class="line"><span class="number">2.</span> <span class="literal">null</span></span><br><span class="line"><span class="number">3.</span> -<span class="number">0</span></span><br><span class="line"><span class="number">4.</span> <span class="number">0</span>或+<span class="number">0</span></span><br><span class="line"><span class="number">5.</span> <span class="title class_">NaN</span></span><br><span class="line"><span class="number">6.</span> <span class="string">&#x27;&#x27;</span>（空字符串）</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>知道了具体转换成什么的规则，但是都在什么情况下发生什么样的转换呢？(什么情况下会自动转换？）</p>
</blockquote>
<p><strong>什么时候自动转换为string类型</strong></p>
<ul>
<li>在没有对象的前提下,发生在字符串的<strong>加法运算。</strong>当一个值为字符串，另一个值为非字符串，则后者转为字符串。</li>
<li>当有对象且与对象<code>+</code>（正）时候</li>
</ul>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//几种特殊对象</span></span><br><span class="line"><span class="string">&#x27;2&#x27;</span> + &#123;&#125; <span class="comment">// &quot;2[object Object]&quot;</span></span><br><span class="line"><span class="string">&#x27;2&#x27;</span> + [] <span class="comment">// &quot;2&quot;</span></span><br><span class="line"><span class="string">&#x27;2&#x27;</span> + <span class="keyword">function</span> (<span class="params"></span>)&#123;&#125; <span class="comment">// &quot;2function ()&#123;&#125;&quot;</span></span><br><span class="line"><span class="string">&#x27;2&#x27;</span> + [<span class="string">&#x27;koala&#x27;</span>,<span class="number">1</span>] <span class="comment">// 2koala,1</span></span><br></pre></td></tr></table></figure></div>



<p><strong>什么时候自动转换为Number类型</strong></p>
<ul>
<li>有加法运算符，但是无<code>String</code>类型的时候，都会优先转换为<code>Number</code>类型</li>
<li><strong>除了加法运算符，其他运算符都会把运算自动转成数值。</strong></li>
</ul>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一元运算符（注意点）</span></span><br><span class="line">+<span class="string">&#x27;abc&#x27;</span> <span class="comment">// NaN</span></span><br><span class="line">-<span class="string">&#x27;abc&#x27;</span> <span class="comment">// NaN</span></span><br><span class="line">+<span class="literal">true</span> <span class="comment">// 1</span></span><br><span class="line">-<span class="literal">false</span> <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">注意：<span class="literal">null</span>转为数值时为<span class="number">0</span>，而<span class="literal">undefined</span>转为数值时为<span class="title class_">NaN</span>。</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>如何判断数据类型？怎么判断一个值到底是数组类型还是对象?</p>
</blockquote>
<ol>
<li>typeof 检测基本数据类型，返回基本数据类型</li>
<li>instanceof 检测引用数据类型，返回true&#x2F;false</li>
<li>Object.prototype.toString.call() 两个都可以检测，返回数据类型</li>
</ol>
<h2 id="三、typeof与instanceof的区别"><a href="#三、typeof与instanceof的区别" class="headerlink" title="三、typeof与instanceof的区别:"></a>三、typeof与instanceof的区别:</h2><ol>
<li><p>typeof操作符右侧跟一个表达式，并返回该表达式的数据类型；能判断所有的值类型，但判断null，数组，对象都返回object</p>
</li>
<li><p>instanceof运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上，通俗一点就是，只要右边变量的prototype在左边变量的原型链上就返回 true，否则返回 false instanceof能准确判断引用类型，不能判断基本类型</p>
</li>
<li><p>检测数据类型：终极方法 Object.prototype.toString.call(）</p>
</li>
</ol>
<h2 id="四、NaN"><a href="#四、NaN" class="headerlink" title="四、NaN"></a>四、NaN</h2><blockquote>
<p>简单说一下NaN</p>
</blockquote>
<p><code>NaN</code>是一个全局对象的属性，<code>NaN</code>是一种特殊的<code>Number</code>类型。</p>
<p><strong>什么情况下返回NaN：</strong></p>
<ul>
<li>无穷大除以无穷大</li>
<li>给任意负数做开方运算</li>
<li>算数运算符与不是数字或无法转换为数字的操作数一起使用</li>
<li>字符串解析成数字</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Infinity</span> / <span class="title class_">Infinity</span>;   <span class="comment">// 无穷大除以无穷大</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">sqrt</span>(-<span class="number">1</span>);         <span class="comment">// 给任意负数做开方运算</span></span><br><span class="line"><span class="string">&#x27;a&#x27;</span> - <span class="number">1</span>;               <span class="comment">// 算数运算符与不是数字或无法转换为数字的操作数一起使用</span></span><br><span class="line"><span class="string">&#x27;a&#x27;</span> * <span class="number">1</span>;</span><br><span class="line"><span class="string">&#x27;a&#x27;</span> / <span class="number">1</span>;</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;a&#x27;</span>);         <span class="comment">// 字符串解析成数字</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&#x27;a&#x27;</span>);   <span class="comment">//NaN</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span> - <span class="number">1</span>   <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">undefined</span> + <span class="number">1</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="comment">//一元运算符（注意点）</span></span><br><span class="line">+<span class="string">&#x27;abc&#x27;</span> <span class="comment">// NaN</span></span><br><span class="line">-<span class="string">&#x27;abc&#x27;</span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure></div>

]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/11/17/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link" href="https://hexo.io/">Hexo<i class="fas fa-external-link-alt"></i></a>! This is your very first post. Check <a class="link" href="https://hexo.io/docs/">documentation<i class="fas fa-external-link-alt"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link" href="https://hexo.io/docs/troubleshooting.html">troubleshooting<i class="fas fa-external-link-alt"></i></a> or you can ask me on <a class="link" href="https://github.com/hexojs/hexo/issues">GitHub<i class="fas fa-external-link-alt"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link" href="https://hexo.io/docs/writing.html">Writing<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link" href="https://hexo.io/docs/server.html">Server<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link" href="https://hexo.io/docs/generating.html">Generating<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link" href="https://hexo.io/docs/one-command-deployment.html">Deployment<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>new Set()</title>
    <url>/2022/04/15/new%20Set()/</url>
    <content><![CDATA[<p><strong>Set集合，ES6标准中提供Set构造函数来创建集合，它是一种无重复元素的列表</strong></p>
<h3 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h3><p>Set通过add()方法向集合中添加元素，访问集合的size属性可以获取集合中目前的元素数量，并且允许存储任何类型的唯一值</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> demo = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">demo.<span class="title function_">add</span>(<span class="string">&#x27;jojo&#x27;</span>)</span><br><span class="line">demo.<span class="title function_">add</span>(<span class="string">&#x27;dio&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(demo) <span class="comment">// Set(2) &#123;&quot;jojo&quot;,&quot;dio&quot;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(demo.<span class="property">size</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></div>

<p><img lazyload src="/images/loading.svg" data-src="/../img/image-20230213192834346.png" alt="image-20230213192834346"></p>
<p>这是由以上代码打印出的，展开后可以看到一个[[Entries]]，那是因为Set的函数返回一个迭代器对象，因此不能以数组的形式去访问它，例如demo[0]，这样打印出来会是一个undefined</p>
<h3 id="delete"><a href="#delete" class="headerlink" title="delete()"></a>delete()</h3><p>可以添加自然也可以删除，通过delete()删除Set集合中的某一个元素</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line">demo.<span class="title function_">delete</span>(<span class="string">&#x27;dio&#x27;</span>) <span class="comment">// Set(1) &#123;&quot;jojo&quot;&#125;</span></span><br></pre></td></tr></table></figure></div>



<h3 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h3><p>清除所有该集合中的元素</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line">demo.<span class="title function_">clear</span>() <span class="comment">// Set(0) &#123;&#125;</span></span><br></pre></td></tr></table></figure></div>



<h3 id="has"><a href="#has" class="headerlink" title="has()"></a>has()</h3><p>判断该集合是否有某个元素</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line">demo.<span class="title function_">add</span>(<span class="number">1</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(demo.<span class="title function_">has</span>(<span class="number">1</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(demo.<span class="title function_">has</span>(<span class="number">2</span>)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure></div>



<h3 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h3><p>一般可以通过Set不可重复的属性进去去重的处理，可以省去部分判断</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line"><span class="keyword">let</span> demo2 = <span class="keyword">new</span> <span class="title class_">Set</span>(arr)</span><br><span class="line">arr = [...demo2]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr) <span class="comment">// [1,2]</span></span><br></pre></td></tr></table></figure></div>



<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><p>顺序对每个元素进行callback函数一次, **<code>callback</code>**被调用三个参数，[values,values,集合本身]</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">a.<span class="title function_">add</span>(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">a.<span class="title function_">add</span>(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">a.<span class="title function_">forEach</span>(<span class="function">(<span class="params">v1,v2,v3</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(v1,v2,v3)</span><br><span class="line">    <span class="comment">// b b Set(2) &#123;&quot;b&quot;, &quot;c&quot;&#125;</span></span><br><span class="line">    <span class="comment">// c c Set(2) &#123;&quot;b&quot;, &quot;c&quot;&#125;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

]]></content>
  </entry>
  <entry>
    <title>new的执行过程</title>
    <url>/2021/10/12/new%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h4 id="new-的执行过程："><a href="#new-的执行过程：" class="headerlink" title="new 的执行过程："></a>new 的执行过程：</h4><ol>
<li>首先创建一个新的空对象</li>
<li>设置原型，将这个对象的原型设置为函数的prototype对象</li>
<li>让函数的this指向这个对象</li>
<li>执行构造函数的代码</li>
<li>给这个新对象添加属性</li>
<li>判断函数的返回值类型，如果是值类型，返回创建的对象，如果是引用类型，返回这个引用类型的对象</li>
</ol>
<p>​	<strong>用代码简单来理解就是：</strong></p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">_new</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> obj = &#123;&#125;<span class="comment">//创建一个新对象</span></span><br><span class="line">	obj.<span class="property">__proto__</span> = fn.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// 新对象继承Person.prototype</span></span><br><span class="line">        fn.<span class="title function_">call</span>(obj);<span class="comment">// 使用指定的参数调用构造函数 Person ，并将 this 绑定到新创建的对象</span></span><br><span class="line">        <span class="keyword">return</span> obj   <span class="comment">//返回最初创建的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>





<h4 id="手写："><a href="#手写：" class="headerlink" title="手写："></a>手写：</h4><ol>
<li>第一参数作为构造函数，其余参数作为构造函数参数</li>
<li>继承构造函数原型创建新对象</li>
<li>执行构造函数</li>
<li>结果为对象，返回结果，反之，返回新对象</li>
</ol>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">One</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">One</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">//age:undefined name:undefined</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Fun为构造函数, args表示传参</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myNew</span>(<span class="params">Fun, ...args</span>) &#123;</span><br><span class="line"><span class="comment">// 1.在内存中创建一个新对象</span></span><br><span class="line">    <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 2.把新对象的原型指针指向构造函数的原型属性</span></span><br><span class="line">    obj.<span class="property">__proto__</span> = <span class="title class_">Fun</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 3.改变this指向，并且执行构造函数内部的代码（传参）</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="title class_">Fun</span>.<span class="title function_">apply</span>(obj, args);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 4.判断函数执行结果的类型</span></span><br><span class="line">    <span class="keyword">if</span> (res <span class="keyword">instanceof</span> <span class="title class_">Object</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="title function_">myNew</span>(<span class="title class_">One</span>, <span class="string">&quot;XiaoMing&quot;</span>, <span class="string">&quot;18&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;newObj:&quot;</span>, obj); <span class="comment">//age:&quot;18&quot; name:&quot;XiaoMing&quot;</span></span><br></pre></td></tr></table></figure></div>

]]></content>
  </entry>
  <entry>
    <title>this指向总结</title>
    <url>/2021/11/17/this%E6%8C%87%E5%90%91/</url>
    <content><![CDATA[<p>this 指向 &#x3D;&#x3D;&#x3D;&gt; 指向 可以理解为 等于 代表谁</p>
<p><strong>this在定义的时候不能确定, 只有执行调用的时候才能确定.!!!</strong></p>
<h4 id="一、默认window"><a href="#一、默认window" class="headerlink" title="一、默认window"></a>一、默认window</h4><p>​	当调用函数的对象位于Window时，函数内的this会默认绑定到Window上</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局作用域</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)  <span class="comment">// window</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数调用</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;大家吃早饭了嘛?&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// window</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器里面</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)  <span class="comment">// window</span></span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>​	但在严格模式下，全局对象Window不能用于默认绑定，this会绑定到undefined</p>
<h4 id="二、对象上下文-隐式绑定"><a href="#二、对象上下文-隐式绑定" class="headerlink" title="二、对象上下文(隐式绑定)"></a>二、对象上下文(隐式绑定)</h4><p>​	一般通过上下文对象调用函数时，函数内的this绑定到该对象</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  方法调用中, 谁调用这个方法, this指向谁</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;yiyi&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">sayHi</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">sayHi</span>() <span class="comment">//obj</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件注册的时候, this指向被绑定的元素</span></span><br><span class="line"><span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>)</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// 绑定事件的元素</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">target</span>) <span class="comment">// 触发事件的元素</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">currentTarget</span>) <span class="comment">// 同this, 绑定事件的元素</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>



<h4 id="三、new绑定"><a href="#三、new绑定" class="headerlink" title="三、new绑定"></a>三、new绑定</h4><p>​	通过构造函数创建实例对象时，this指向这个实例对象</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数中, this 指向的是 构造函数的实例</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> <span class="title class_">Foo</span>(<span class="string">&#x27;小红&#x27;</span>, <span class="number">19</span>) <span class="comment">//new Foo(&#x27;小红&#x27;, 19)</span></span><br><span class="line"><span class="keyword">const</span> person2 = <span class="keyword">new</span> <span class="title class_">Foo</span>(<span class="string">&#x27;小白&#x27;</span>, <span class="number">18</span>) <span class="comment">//new Foo(&#x27;小白&#x27;, 18)</span></span><br></pre></td></tr></table></figure></div>

<p>​	因为new的执行过程中，会让函数的this指向这个对象</p>
<h4 id="四、显式绑定"><a href="#四、显式绑定" class="headerlink" title="四、显式绑定"></a>四、显式绑定</h4><p>​	通过call、apply、bind显式调用函数时，函数内的this会绑定到指定参数的对象上</p>
<h5 id="1-call改变this指向"><a href="#1-call改变this指向" class="headerlink" title="1. call改变this指向"></a>1. call改变this指向</h5><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// call可以改变this的指向</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">msg</span>:<span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> abc = &#123;</span><br><span class="line">    <span class="attr">demo</span>:<span class="string">&#x27;hahaha&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x, y</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> res = fn.<span class="title function_">call</span>(obj, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res) <span class="comment">//3</span></span><br></pre></td></tr></table></figure></div>

<p><strong>fn.call()</strong></p>
<ol>
<li>改变this的指向</li>
<li>会调用函数，立即执行，返回函数调用结果</li>
<li>注意：第一个参数就是要让this指向哪个对象，后面紧跟的是参数列表</li>
</ol>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">            <span class="attr">name</span>:<span class="string">&#x27;hw&#x27;</span>,</span><br><span class="line">    <span class="title function_">getName</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj3 = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;iphone&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">obj2.<span class="title function_">getName</span>() <span class="comment">//hw</span></span><br><span class="line">obj2.<span class="property">getName</span>.<span class="title function_">call</span>(obj3)  <span class="comment">//iphone</span></span><br></pre></td></tr></table></figure></div>



<h5 id="2-apply改变this指向"><a href="#2-apply改变this指向" class="headerlink" title="2. apply改变this指向"></a>2. apply改变this指向</h5><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">msg</span>: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> abc = &#123;</span><br><span class="line">    <span class="attr">demo</span>: <span class="string">&#x27;哈哈哈哈&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// msg: &#x27;hello&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// fn(1, 2)</span></span><br><span class="line"><span class="comment">// fn.apply(this指向谁, [数组])</span></span><br><span class="line"><span class="keyword">const</span> res = fn.<span class="title function_">apply</span>(obj, [<span class="number">1</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure></div>

<p><strong>fn.apply()</strong></p>
<ol>
<li>改变this的指向</li>
<li>调用函数，立即执行</li>
<li>返回值就是函数本身的返回值</li>
</ol>
<p><strong>注意：</strong>apply的第二个参数是数组</p>
<h5 id="3-bind改变this指向"><a href="#3-bind改变this指向" class="headerlink" title="3.bind改变this指向"></a>3.bind改变this指向</h5><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">one</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;123&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> two = one.<span class="title function_">bind</span>(user)</span><br><span class="line"><span class="title function_">two</span>() <span class="comment">//age: 18 name: &quot;123&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>fn.bind(obj, 参数列表)</p>
<ul>
<li>改变this指向</li>
<li>有返回值，返回值是一个函数，这个函数里面的this指向的就是bind的第一个参数</li>
<li>不会立即执行，需要我们手动调用执行</li>
</ul>
<h5 id="call-apply-bind的区别"><a href="#call-apply-bind的区别" class="headerlink" title="call apply bind的区别:"></a>call apply bind的区别:</h5><ol>
<li>三个都可以改变this指向</li>
<li>call、bind接收的是一个参数列表，apply接收的是一个数组</li>
<li>call、apply都是立即执行的，bind是返回一个函数，需要手动调用</li>
</ol>
<h3 id="五、箭头函数"><a href="#五、箭头函数" class="headerlink" title="五、箭头函数"></a>五、箭头函数</h3><p>箭头函数中，由于箭头函数没有自己的this，它只会从自己作用域链的上一层继承this，而且箭头函数的this不能被改变</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 箭头函数没有prototype，原型</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">A</span> = (<span class="params"></span>) =&gt; &#123;&#125;</span><br><span class="line"><span class="comment">// 2. 不能使用new调用箭头函数，也就是它不能作为构造函数</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">b</span> = (<span class="params"></span>) =&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> <span class="title function_">b</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 箭头函数没有arguments对象，可以利用rest接收剩余参数</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">a</span> = (<span class="params">first, ...rest</span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(first,rest)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">a</span>(<span class="number">123</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 箭头函数本身没有this，</span></span><br><span class="line"><span class="comment">// 箭头函数的this在定义的时候就确定了，指向的是上层作用域中的this</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> msg = <span class="string">&#x27;666&#x27;</span>  <span class="comment">// let声明的变量，不会挂载到window上</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">msg</span>:<span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">    <span class="attr">say</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;say: &#x27;</span>, <span class="variable language_">this</span>.<span class="property">msg</span>)  <span class="comment">// say: xxx</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">sayHi</span>:<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sayHi: &#x27;</span>, <span class="variable language_">this</span>.<span class="property">msg</span>) <span class="comment">// sayHi: undefined   window.msg</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">say</span>()</span><br><span class="line">obj.<span class="title function_">sayHi</span>()</span><br></pre></td></tr></table></figure></div>

]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>title</title>
    <url>/2022/11/17/title/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>事件循环</title>
    <url>/2020/01/17/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>函数参数</title>
    <url>/2020/12/09/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<h3 id="argunments-对象"><a href="#argunments-对象" class="headerlink" title="argunments 对象"></a>argunments 对象</h3><ol>
<li><p>除箭头函数以外，所有的函数都内置了（默认就存在，自带的）一个arguments对象</p>
</li>
<li><p>arguments 伪&#x2F;类数组 有length，有索引，没有push，pop等数组方法&#x3D;&#x3D;&#x3D;&gt; 接收了&#x2F;存储了我们传递过来的传参</p>
</li>
<li><p>arguments 对象，只存在于函数中</p>
</li>
</ol>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getSum</span>(<span class="params">a,b</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">            <span class="comment">// console.log(argunments)</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; argunments.<span class="property">length</span>; i++)&#123;</span><br><span class="line">                sum += <span class="variable language_">arguments</span>[i]</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">return</span> sum</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// const res = getSum(2,3)</span></span><br><span class="line">        <span class="keyword">const</span> res = <span class="title function_">getSum</span>(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 箭头函数没有arguments</span></span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params"></span>) =&gt;&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">fn</span>()</span><br></pre></td></tr></table></figure></div>



<h3 id="剩余参数-rest"><a href="#剩余参数-rest" class="headerlink" title="剩余参数 rest"></a>剩余参数 rest</h3><p>形式 …变量名 变量名自定义</p>
<ol>
<li>剩余参数rest 是一个真数组，存了剩余的实参</li>
<li>只能放到参数的最后一位</li>
</ol>
<h3 id="spread-扩展运算符"><a href="#spread-扩展运算符" class="headerlink" title="spread 扩展运算符"></a>spread 扩展运算符</h3><p>扩展运算符（spread）是三个点（…)</p>
<p>它好比rest 参数的逆运算</p>
<p>作用： 它不会改变原数组</p>
<p><strong>主要引用</strong></p>
<h4 id="1-求一个数组的最大最小值"><a href="#1-求一个数组的最大最小值" class="headerlink" title="1. 求一个数组的最大最小值"></a>1. 求一个数组的最大最小值</h4><div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">11</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">77</span>]</span><br><span class="line">        <span class="comment">// Math.max() 它本身接收的是参数列表</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">max</span>(...arr2))</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">min</span>(...arr2))</span><br></pre></td></tr></table></figure></div>

<h4 id="2-复制-x2F-拷贝数组-浅拷贝"><a href="#2-复制-x2F-拷贝数组-浅拷贝" class="headerlink" title="2. 复制&#x2F;拷贝数组 (浅拷贝)"></a>2. 复制&#x2F;拷贝数组 (浅拷贝)</h4><div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">const</span> a2 = a1</span><br><span class="line">        <span class="comment">// 赋值，数组的直接赋值，赋的是地址，指向的是堆内存中同一个数组对象</span></span><br><span class="line">        a2[<span class="number">0</span>] === <span class="number">666</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a3 = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">        <span class="keyword">const</span> a4 = [...a3] <span class="comment">// ==&gt;[5,6,7]</span></span><br><span class="line">        a3[<span class="number">0</span>] = <span class="number">9</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a3) <span class="comment">//[5,6,7]</span></span><br><span class="line">        <span class="comment">// ==&gt; 数组里面的元素是基本数据类型，修改数组元素的值，相互不影响</span></span><br></pre></td></tr></table></figure></div>

<h4 id="3-合并数组-浅拷贝"><a href="#3-合并数组-浅拷贝" class="headerlink" title="3.合并数组 (浅拷贝)"></a>3.合并数组 (浅拷贝)</h4><div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a5 = [<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line">        <span class="keyword">const</span> a6 = [<span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ES5 的合并 concat</span></span><br><span class="line">        <span class="keyword">const</span> resArr = a5.<span class="title function_">concat</span>(a6)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(resArr)</span><br><span class="line">        <span class="comment">// ES6 ...</span></span><br><span class="line">        <span class="keyword">const</span> a7 = [...a5, ...a6]</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a7)</span><br></pre></td></tr></table></figure></div>

<h4 id="4-将字符串转为数组"><a href="#4-将字符串转为数组" class="headerlink" title="4.将字符串转为数组"></a>4.将字符串转为数组</h4><div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [...str] ===&gt; 将字符串展开为数组</span></span><br><span class="line">        <span class="keyword">const</span> str = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">        <span class="keyword">const</span> a8 = [...<span class="string">&#x27;hello&#x27;</span>]</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a8)</span><br><span class="line">        <span class="comment">// 反转字符串</span></span><br><span class="line">        <span class="keyword">const</span> res = str.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ==&gt; 扩展运算符的方式</span></span><br><span class="line">        <span class="keyword">const</span> resStr = [...str].<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// ===&gt; 推荐</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(resStr)</span><br></pre></td></tr></table></figure></div>

<h4 id="5-把伪数组转为真数组"><a href="#5-把伪数组转为真数组" class="headerlink" title="5.把伪数组转为真数组"></a>5.把伪数组转为真数组</h4><div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> divs = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(divs)</span><br><span class="line">        <span class="comment">// divs.push(666) 伪数组报错</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> resDiv = [...divs]</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(resDiv)</span><br><span class="line">        resDiv.<span class="title function_">push</span>(<span class="number">666</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(resDiv)</span><br><span class="line"></span><br><span class="line"><span class="comment">//将伪数组转为真数组</span></span><br><span class="line"><span class="comment">//[...likeArr] 使用扩展运算符</span></span><br><span class="line"><span class="comment">//Array.from(likeArr)</span></span><br></pre></td></tr></table></figure></div>

]]></content>
  </entry>
  <entry>
    <title>作用域</title>
    <url>/2021/02/25/%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<p>​	变量和函数的可访问范围 ，就是作用域控制着变量和函数的可见性 和 生命周期</p>
<h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p>直接卸载script或者JS代码（单独的JS文件），属于全局作用域</p>
<p>可见性：全局作用域中声明的变量，在代码的任何地方都可以访问</p>
<p>生命周期：伴随着页面的生命周期（页面关闭，销毁）</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="number">10</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 函数内部</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(num)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">fn</span>() <span class="comment">//10</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// eg2 </span></span><br><span class="line">  <span class="comment">// 函数内部，如果不使用任何关键字声明变量，那么这个变量会变成window的属性</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">      abc = <span class="number">100</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">bar</span>()</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(abc)<span class="comment">//100</span></span><br></pre></td></tr></table></figure></div>



<h3 id="局部作用域（函数作用域）"><a href="#局部作用域（函数作用域）" class="headerlink" title="局部作用域（函数作用域）"></a>局部作用域（函数作用域）</h3><p>变量只能在函数内部访问，外部无法访问</p>
<p>可见性：函数外部不能访问函数内部的变量</p>
<p>生命周期：变量在函数调用执行后，就会销毁（清空&#x2F;回收）</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> abc = <span class="number">666</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(abc)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure></div>



<h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p><strong>为什么需要块级作用域？</strong></p>
<p>用var声明变量时，内层变量可能覆盖外层变量，用来计数的循环变量i，会泄漏为全局变量</p>
<p>{}包裹起来的叫代码块，使用let或者const声明的变量，在<code>&#123;&#125;</code>中会产生块级作用域</p>
<p>特点：</p>
<ol>
<li>只有let、const 会产生块级作用域{}</li>
</ol>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">         <span class="keyword">const</span> obj = &#123;</span><br><span class="line">             <span class="attr">name</span>:<span class="string">&#x27;ll&#x27;</span>,</span><br><span class="line">             <span class="attr">age</span>:<span class="number">18</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(obj)</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(obj)</span><br></pre></td></tr></table></figure></div>

<ol>
<li>块级作用域外部不能访问内部的变量</li>
</ol>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br></pre></td></tr></table></figure></div>

<ol>
<li>两个块级作用域中的变量相互不影响</li>
</ol>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></div>

<ol>
<li>if&#x2F;for是语句，但是let&#x2F;const声明的变量，会在内部形成块级作用域</li>
</ol>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> temp = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="var、let、const的区别"><a href="#var、let、const的区别" class="headerlink" title="var、let、const的区别"></a>var、let、const的区别</h3><ol>
<li>let &#x2F; const 可以形成块级作用域</li>
<li>let &#x2F; const 不存在变量提升，var存在</li>
<li>let &#x2F; const 不允许重复声明，var允许</li>
<li>let &#x2F; const 存在暂时性死区TDZ</li>
<li>浏览器中，var声明的全局变量会挂载到window对象上</li>
</ol>
<p>const ：一旦声明，必须马上赋值，并且不能改变值（简单类型不能改变值，引用类型不能改变地址）</p>
<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p><strong>什么是作用域链</strong>？</p>
<p>函数是可以嵌套函数的，每个函数都有一个局部作用域，这样子，也会形成作用域的嵌套</p>
<p>当访问内层作用域中的某个变量的时候，首先在当前作用域中查找这个变量，如果不存在，往上层查找，直到全局作用域</p>
<p>作用域的本质：底层变量的查找机制 </p>
<p>查找规则：</p>
<ol>
<li>优先在当前作用域中查找变量</li>
<li>如果不存在，往上层作用域中查找变量，直到全局作用域</li>
</ol>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局作用域</span></span><br><span class="line">        <span class="keyword">let</span> a = <span class="number">3</span></span><br><span class="line">        <span class="keyword">let</span> b = <span class="number">1</span></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="comment">// 局部作用域</span></span><br><span class="line">            <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">            <span class="keyword">function</span> <span class="title function_">g</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="comment">// 局部作用域</span></span><br><span class="line">                a = <span class="number">2</span></span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_">g</span>() <span class="comment">// 调用g</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">f</span>() <span class="comment">// 调用f</span></span><br></pre></td></tr></table></figure></div>

]]></content>
  </entry>
  <entry>
    <title>解释一下原型和原型链</title>
    <url>/2021/12/11/%E5%8E%9F%E5%9E%8B%E4%BB%A5%E5%8F%8A%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<h3 id="原型prototype"><a href="#原型prototype" class="headerlink" title="原型prototype"></a>原型prototype</h3><p>原型：字面意思 原来的模型， 原始祖先， 原始的模型</p>
<p>JS原型 ： 原型就是一个对象，也叫原型对象</p>
<ol>
<li>所有的函数，都有一个prototype属性（显示原型），这个属性是一个指针，指向原型对象。（原型）</li>
</ol>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">dir</span>(<span class="title class_">Person</span>)</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>原型上默认有一个叫做constructor的属性，指向这个构造函数本身</li>
</ol>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person.prototype ==&gt; &#123;</span></span><br><span class="line"><span class="comment">//     constructor: Person</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Person</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li>我们可以往这个原型对象中添加属性和方法</li>
</ol>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sing</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hahaha&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">demo</span> = <span class="string">&#x27;我是原型上的一个属性&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">dir</span>(<span class="title class_">Person</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Star</span>(<span class="params">name, age</span>)&#123;</span><br><span class="line">    <span class="comment">// 公共的属性写到构造函数上面</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共的方法写到原型对象上  节约了内存</span></span><br><span class="line"><span class="title class_">Star</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sing</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sing&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Star</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">cheer</span> = <span class="string">&#x27;Day Day up&#x27;</span></span><br></pre></td></tr></table></figure></div>

<ol start="4">
<li>所有通过构造函数创建的对象，都共享原型上的属性和方法！</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="variable">ldh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Star</span>(<span class="string">&#x27;刘德华&#x27;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="type">const</span> <span class="variable">zxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Star</span>(<span class="string">&#x27;张学友&#x27;</span>, <span class="number">21</span>)</span><br><span class="line"></span><br><span class="line">ldh.sing()</span><br><span class="line">zxy.sing()</span><br><span class="line">console.log(ldh.cheer)</span><br><span class="line">console.log(zxy.cheer)</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(ldh, zxy)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ldh.__proto__ === Star.prototype</span></span><br></pre></td></tr></table></figure></div>



<h3 id="构造函数中的原型方法"><a href="#构造函数中的原型方法" class="headerlink" title="构造函数中的原型方法"></a>构造函数中的原型方法</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">let</span> <span class="variable">that</span> <span class="operator">=</span> <span class="literal">null</span>  <span class="comment">// 全局变量</span></span><br><span class="line">function <span class="title function_">Star</span><span class="params">(name, age)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">    console.log(<span class="built_in">this</span>)   <span class="comment">// 指向的是实例 Star &#123;name: &#x27;团团&#x27;, age: 7&#125;</span></span><br><span class="line">    that = <span class="built_in">this</span> <span class="comment">// that把this的指向/状态 保存起来了 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>​	我们声明了一个全局变量that，在调用new的时候，保存this的状态， 调用结束后，<br>​	如果that还是指向构造函数创建的实例，说明我们的结论没问题</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> that1 = <span class="literal">null</span></span><br><span class="line"><span class="title class_">Star</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sing</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sing&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)   <span class="comment">// Star &#123;name: &#x27;团团&#x27;, age: 7&#125;</span></span><br><span class="line">    that1 = <span class="variable language_">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol>
<li>构造函数里面的this指向的是实例</li>
</ol>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> tt = <span class="keyword">new</span> <span class="title class_">Star</span>(<span class="string">&#x27;团团&#x27;</span>, <span class="number">7</span>)</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>原型方法中的this指向的还是实例</li>
</ol>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">tt.<span class="title function_">sing</span>()   <span class="comment">// 调用之后才能执行，才能看this指向</span></span><br></pre></td></tr></table></figure></div>



<h3 id="constructor属性"><a href="#constructor属性" class="headerlink" title="constructor属性"></a>constructor属性</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">function <span class="title function_">Star</span><span class="params">(name, age)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="variable">tt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Star</span>(<span class="string">&#x27;团团&#x27;</span>, <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// constructor</span></span><br><span class="line">console.dir(Star)</span><br></pre></td></tr></table></figure></div>

<p>​	首先，constructor在原型（对象）上，每个原型（对象）上默认都有一个constructor属性，指向构造函数本身，表示我，我这个原型，是哪个构造函数的原型 和哪个构造函数相关联，&#x3D;&#x3D;&gt; 其实就相当于是一个标识</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Star</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Star</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有对象的隐式原型都指向构造函数的显示原型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(tt.<span class="property">__proto__</span> === <span class="title class_">Star</span>.<span class="property"><span class="keyword">prototype</span></span>)    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// tt.__proto__ ==&gt; 指向的也是原型对象，找到的</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(tt.<span class="property">__proto__</span>.<span class="property">constructor</span> === <span class="title class_">Star</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>



<h3 id="constructor的应用"><a href="#constructor的应用" class="headerlink" title="constructor的应用"></a>constructor的应用</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每个原型对象中都有一个constructor属性，指回构造函数本身</span></span><br><span class="line">function <span class="title function_">Star</span><span class="params">(name, age)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1. 这种方式给原型添加公共方法，不会修改原型</span></span><br><span class="line"><span class="comment">// Star.prototype.sing = function()&#123;</span></span><br><span class="line"><span class="comment">//     console.log(&#x27;sing&#x27;)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// Star.prototype.dance = function()&#123;</span></span><br><span class="line"><span class="comment">//     console.log(&#x27;dance&#x27;)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// Star.prototype.rap = function()&#123;</span></span><br><span class="line"><span class="comment">//     console.log(&#x27;rap&#x27;)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure></div>

<p>如果直接给Star.prototype赋值一个对象，这个时候，原型上的默认属性constructor就会丢失我们可以手动给这个对象添加constructor属性，指回这个构造函数</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2. 这种以对象赋值的方式，会覆盖掉原型。 需要我们手动添加一个constructor属性</span></span><br><span class="line">Star.prototype = &#123;</span><br><span class="line">    constructor: Star,</span><br><span class="line">    sing:function()&#123;</span><br><span class="line">        console.log(<span class="string">&#x27;sing&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    dance:function()&#123;</span><br><span class="line">        console.log(<span class="string">&#x27;dance&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    rap:function()&#123;</span><br><span class="line">        console.log(<span class="string">&#x27;rap&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="variable">tt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Star</span>(<span class="string">&#x27;团团&#x27;</span>, <span class="number">7</span>)</span><br><span class="line">tt.__proto__ === Star.prototype  <span class="comment">// ==&gt; 原型对象</span></span><br><span class="line">console.log(ldh)</span><br><span class="line">tt.sing()</span><br><span class="line">tt.dance()</span><br></pre></td></tr></table></figure></div>



<h3 id="隐式属性"><a href="#隐式属性" class="headerlink" title="隐式属性"></a>隐式属性</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">function <span class="title function_">Star</span><span class="params">(name, age)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Star.prototype.sing = function()&#123;</span><br><span class="line">    console.log(<span class="string">&#x27;sing&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="variable">tt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Star</span>(<span class="string">&#x27;团团&#x27;</span>, <span class="number">7</span>)</span><br></pre></td></tr></table></figure></div>

<ol>
<li>所有对象，都有一个__proto__属性（隐式原型），属性值也是一个对象（其实就是指向原型对象）</li>
<li>__proto__隐式原型</li>
</ol>
<p>&#x3D;&#x3D;&gt; 实例通过__proto__访问(链接)到了它的原型对象</p>
<p>&#x3D;&#x3D;&gt; __proto__相当于一个桥梁，链接，实例就通过__proto__访问到原型对象</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2. 对象的隐式原型指向构造函数的显示原型</span></span><br><span class="line">tt.__proto__ === Star.prototype <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">function <span class="title function_">Animal</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.color = <span class="string">&#x27;orange&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>()</span><br><span class="line">console.log(cat)</span><br><span class="line"></span><br><span class="line">console.log(cat.__proto__ === Animal.prototype)     <span class="comment">// true</span></span><br><span class="line">console.log(Animal.prototype.constructor === Animal)    <span class="comment">//true</span></span><br><span class="line">console.log(cat.__proto__.constructor === Animal)   <span class="comment">//true</span></span><br></pre></td></tr></table></figure></div>

<ol>
<li><p>实例对象.<strong>proto</strong> &#x3D;&#x3D;&#x3D; 构造函数.prototype’ &#x3D;&#x3D;&gt; 原型</p>
</li>
<li><p><strong>proto</strong> 表示了实例和原型之间的一个关系，相当于就是一个桥梁，实例通过它访问原型</p>
</li>
</ol>
<h3 id="构造函数-实例-原型的关系"><a href="#构造函数-实例-原型的关系" class="headerlink" title="构造函数-实例-原型的关系"></a>构造函数-实例-原型的关系</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">function <span class="title function_">Person</span><span class="params">(name)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br></pre></td></tr></table></figure></div>

<p>四条线：</p>
<ol>
<li>构造函数.prototype &#x3D;&#x3D;&#x3D;&gt; 原型对象</li>
<li>原型对象.constructor &#x3D;&#x3D;&#x3D;&gt; 构造函数</li>
<li>实例对象.<strong>proto</strong> &#x3D;&#x3D;&#x3D;&gt; 原型对象</li>
<li>构造函数 new , 创建出 实例对象</li>
</ol>
<p>高程四 第八章 P250 : 实例与构造函数原型之间有直接的联系（<strong>proto</strong>），但实例与构造函数之间没有直接联系</p>
<p><img lazyload src="/images/loading.svg" data-src="/../img/image-20230213204512399.png" alt="image-20230213204512399"></p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">function <span class="title function_">Person</span><span class="params">(name)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"></span><br><span class="line">console.log(person.__proto__)   <span class="comment">// ===&gt; person这个实例对象的原型</span></span><br><span class="line">console.log(Person.prototype)   <span class="comment">// ===&gt; Person构造函数的原型</span></span><br><span class="line"></span><br><span class="line">person.__proto__ === Person.prototype</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型链：</span></span><br><span class="line"><span class="comment">// ==&gt;所有的对象都有一个__proto__，属性值也是一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. Person.prototype也是一个对象，所以，它也有__proto__属性，属性值也是对象。</span></span><br><span class="line"><span class="comment">// console.dir(Person)</span></span><br><span class="line">console.log(Person.prototype.__proto__)  <span class="comment">// ===&gt; __proto__ 访问到原型</span></span><br><span class="line"><span class="comment">// Person.prototype.__proto__ ===&gt; &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ==&gt; 原型上默认有一个constructor属性，指回的构造函数(我们通过这个知道了Person.prototype的构造函数是Object)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ==&gt; 规则4 所有对象的隐式原型指向它的构造函数的显示原型</span></span><br><span class="line"><span class="comment">// Person.prototype</span></span><br><span class="line">Person.prototype.__proto__ === Object.prototype</span><br><span class="line"><span class="comment">// person.__proto__ === Person.prototype</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Person.prototype.__proto__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===&gt; Person.prototype 这个原型对象 是 Object这个构造函数创建的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Object  它是一个构造函数</span></span><br><span class="line"><span class="comment">// Object.prototype ===&gt; 得到的也是一个原型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.prototype这个原型上默认有一个constructor属性，指向构造函数本身</span></span><br><span class="line">Object.prototype.constructor === Object</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.prototype                ===&gt; 原型</span></span><br><span class="line"><span class="comment">// Person.prototype.__proto__      ===&gt; 原型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也就是，上面这两个 指向的 都是 Object这个构造函数的原型</span></span><br><span class="line">console.log(Person.prototype.__proto__ === Object.prototype)    <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>

<p>我们说的原型,可以说是构造函数的原型,也可以说实例的原型,指的都是同一个</p>
<p>构造函数 通过 prototype 访问到它的原型</p>
<p>实例   通过 <strong>proto</strong> 访问到它的原型</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3. Object.prototype</span></span><br><span class="line"><span class="comment">// Object.prototype它也是一个原型对象，所以，它也有一个__proto__属性</span></span><br><span class="line">console.log(Object.prototype)</span><br><span class="line">console.log(Object.prototype.__proto__ === <span class="literal">null</span>)</span><br></pre></td></tr></table></figure></div>

<p>正常的原型链终止到Object.prototype, 也就是Object.prototype.<strong>proto</strong> &#x3D;&#x3D;&#x3D; null</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="什么是原型？"><a href="#什么是原型？" class="headerlink" title="什么是原型？"></a>什么是原型？</h4><ol>
<li>原型就是一个对象</li>
<li>.每个函数都有prototype属性，它的值是一个指针（地址），指向的就是原型对象</li>
<li>通过构造函数创建的实例，都有一个__proto__属性，也指向原型对象</li>
<li>原型上默认有个constructor属性，指回构造函数</li>
<li>我们可以把一些公共的属性和方法放到原型上，节约内存</li>
<li>所有通过构造函数创建的实例都共享原型上的属性和方法</li>
</ol>
<h4 id="什么是原型链？"><a href="#什么是原型链？" class="headerlink" title="什么是原型链？"></a>什么是原型链？</h4><ol>
<li>每个对象通过__proto__属性都能访问到它的原型（对象），原型对象也有它的原型对象（原型也有它的原型）</li>
<li>当访问一个对象属性或方法的时候，先在自身中寻找</li>
<li>如果没有，就会沿着__proto__这条链向上查找，知道最顶层Object.prototype为止</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>变量提升和函数提升</title>
    <url>/2020/11/17/%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E5%92%8C%E6%8F%90%E5%8D%87/</url>
    <content><![CDATA[<p>在es6之前没有块级作用域</p>
<p>js代码的执行分为两个阶段：</p>
<p>第一个阶段，在当前词法环境中注册所有的变量和函数声明，就是解析</p>
<p>第二个阶段，解析完成，进行执行</p>
<ul>
<li>词法：词法作用域根据<strong>源代码声明变量的位置</strong>来确定变量在何处可用嵌套函数可访问声明</li>
</ul>
<h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p>用var声明会有变量提升</p>
<ul>
<li>var声明的变量会在执行之前，提升到当前作用域的最前面</li>
<li>只提升变量声明，不提升变量赋值，然后依次执行代码</li>
<li>如果不赋值，默认undefined</li>
</ul>
<p>不建议使用var声明变量</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a; <span class="comment">// 声明</span></span><br><span class="line">        <span class="keyword">var</span> b = <span class="number">6</span> <span class="comment">// 声明并赋值  ==&gt; 初始化</span></span><br><span class="line"></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(num + <span class="string">&#x27;把剑&#x27;</span>)  <span class="comment">// undefined把剑</span></span><br><span class="line">        <span class="keyword">var</span> num = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(num)  <span class="comment">// undefined</span></span><br><span class="line">            <span class="keyword">var</span> num = <span class="number">29</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">fn</span>()</span><br></pre></td></tr></table></figure></div>



<h3 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h3><p><strong>创建函数的两种方式：</strong></p>
<ol>
<li>函数声明式</li>
</ol>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span> (num1, num2) &#123;</span><br><span class="line"><span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>函数表达式</li>
</ol>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="keyword">function</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>只有<strong>函数声明</strong>才存在函数提升</p>
<p><strong>js只提升声明，不提升初始化</strong> （值），如果先使用变量在声明并初始化（赋值），变量是undefined</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num) <span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"><span class="keyword">var</span> num</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num)</span><br><span class="line">num = <span class="number">5</span></span><br></pre></td></tr></table></figure></div>

<p><strong>总结：</strong></p>
<ol>
<li>会把用function声明的函数，提升到当前作用域的最前面</li>
<li>表达式的情况，如果是用var声明的函数，只提升声明，不提升赋值 &#x3D;&#x3D; &gt; 建议：先声明，后调用</li>
</ol>
<h3 id="变量提升和函数提升的区别"><a href="#变量提升和函数提升的区别" class="headerlink" title="变量提升和函数提升的区别"></a>变量提升和函数提升的区别</h3><ol>
<li>都会提升到当前作用域最顶端</li>
<li>只有声明本身会被提升，而赋值操作不会被提升</li>
<li>函数提升只提升声明式，不提升表达式</li>
<li>函数提升的优先级大于变量提升的优先级</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>关于回流重绘</title>
    <url>/2020/06/06/%E5%9B%9E%E6%B5%81%E9%87%8D%E7%BB%98/</url>
    <content><![CDATA[<h2 id="一-需要先了解一下浏览器的渲染机制"><a href="#一-需要先了解一下浏览器的渲染机制" class="headerlink" title="一.需要先了解一下浏览器的渲染机制"></a>一.需要先了解一下浏览器的渲染机制</h2><p><img lazyload src="/images/loading.svg" data-src="/./img/2022111-160838.jpg" alt="2022111-160838.jpg"></p>
<p>从上面这个图，我们可以看到，浏览器渲染过程如下：</p>
<ol>
<li><p>解析HTML，生成DOM树，解析CSS，生成CSS OM</p>
</li>
<li><p>将DO M树和CSSOM树结合，生成渲染树</p>
</li>
<li><p>回流：根据生成的渲染树进行回流，得到节点的位置，大小等</p>
</li>
<li><p>重绘：根据渲染树以及回流得到的信息进行绘制</p>
</li>
<li><p>最后展示在页面上</p>
<p> <strong>回流一定会引起重绘，重绘不一定会引起回流</strong></p>
</li>
</ol>
<p>看一下DOM树和CSSOM树是怎么样合成为渲染树的</p>
<p><img lazyload src="/images/loading.svg" data-src="/./img/49d3106613e04a9ab56b108ddbb19f4a.png" alt="49d3106613e04a9ab56b108ddbb19f4a.png"></p>
<p>浏览器在把这两个树进行合成渲染树的过程中会确定我们的节点是否可见，和各个节点的样式并精确他们的位置</p>
<p>这里可以看到，如果对一个元素使用了display：none，那么在渲染树中是不存在这个元素的。所以渲染树只包含可见节点</p>
<h2 id="二、回流"><a href="#二、回流" class="headerlink" title="二、回流"></a>二、回流</h2><p>当我们渲染树中的一些元素的结构或者尺寸等发生改变，浏览器重新渲染 部分或者全部文档的过程就叫做回流。</p>
<p><strong>会导致回流的操作：</strong></p>
<ol>
<li>页面首次渲染</li>
<li>浏览器窗口大小发生变化（如果是按照百分比布局的话，元素的宽度发生变化，就相当于尺寸发生变化，会引起回流）</li>
<li>内容变换 ，比如文本变化或图片被另一个不同尺寸的图片所替代</li>
<li>添加或者删除可见的节点</li>
<li>元素的位置发生变化</li>
<li>元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）</li>
</ol>
<p>…</p>
<h2 id="三、重绘"><a href="#三、重绘" class="headerlink" title="三、重绘"></a>三、重绘</h2><p>当页面中元素样式的改变不影响它在文档流中的位置，浏览器会将样式复制给元素，这个过程叫做重绘。</p>
<h2 id="四、如何减少回流、重绘"><a href="#四、如何减少回流、重绘" class="headerlink" title="四、如何减少回流、重绘"></a>四、如何减少回流、重绘</h2><ul>
<li><p>合并对DOM样式的修改，采用css class来修改</p>
  <div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>)再</span><br><span class="line">box.<span class="property">style</span>.<span class="property">margin</span> = <span class="string">&#x27;5px&#x27;</span></span><br><span class="line">box.<span class="property">style</span>.<span class="property">borderRadius</span> = <span class="string">&#x27;12px&#x27;</span></span><br><span class="line">box.<span class="property">style</span>.<span class="property">boxShadow</span> = <span class="string">&#x27;1px 3px 4px #ccc&#x27;</span></span><br></pre></td></tr></table></figure></div>
<p>  建议使用css class</p>
  <div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line">.<span class="property">active</span>&#123; </span><br><span class="line"> <span class="attr">margin</span>: 5px; </span><br><span class="line"> border-<span class="attr">dadius</span>: 12px; </span><br><span class="line"> box-<span class="attr">shadow</span>: 1px 3px 4px #ccc&#125;</span><br><span class="line"><span class="keyword">const</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>).<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;active&#x27;</span>)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>将DOM离线</p>
  <div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先为元素设置display：none操作结束后再把它显示出来。</span></span><br><span class="line"><span class="comment">//因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘，</span></span><br><span class="line"><span class="comment">//操作完之后再将display改为显示，只会触发一次回流与重绘</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> container = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;container&#x27;</span>)</span><br><span class="line">container.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span></span><br><span class="line">container.<span class="property">style</span>.<span class="property">width</span> = <span class="string">&#x27;100px&#x27;</span></span><br><span class="line">container.<span class="property">style</span>.<span class="property">height</span> = <span class="string">&#x27;200px&#x27;</span></span><br><span class="line">container.<span class="property">style</span>.<span class="property">border</span> = <span class="string">&#x27;10px solid red&#x27;</span></span><br><span class="line">container.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;red&#x27;</span></span><br><span class="line">...（省略了许多类似的后续操作）</span><br><span class="line">container.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;block&#x27;</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>当需要对多个DOM进行操作的时候，避免直接对单个DOM进行操作</p>
  <div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用 createDocumentFragment （创建文档碎片节点）方法创建虚拟的 dom 对象</span></span><br><span class="line"><span class="comment">// 这样的能将对 dom 的多次修改合并为一次，就能减少回流和重绘的次数</span></span><br><span class="line">    <span class="keyword">let</span> ul = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;ul&#x27;</span>)</span><br><span class="line">    <span class="keyword">let</span> box = <span class="variable language_">document</span>.<span class="title function_">createDocumentFragment</span>()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> li = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;li&quot;</span>)</span><br><span class="line">        li.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(i))</span><br><span class="line">        box.<span class="title function_">appendChild</span>(li)</span><br><span class="line">    &#125;</span><br><span class="line">    ul.<span class="title function_">appendChild</span>(box）</span><br><span class="line"><span class="comment">//createDocumentFragment使用appendChild追加子元素时，</span></span><br><span class="line"><span class="comment">//如果把它追加进页面中，则插入的是它本身和它的所有子孙节点</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局，如果一个表很大的话，浏览器会等全部渲染好在进行下一步，这个等待的过程会降低用户体验</p>
</li>
<li><p>尽可能不要修改影响范围比较大的 DOM，就是如果你要改变子元素的样式，就不要去它的父元素设置，不通过父元素去影响子元素，直接修改子元素。</p>
</li>
<li><p>动画实现速度的选择，动画速度越快，回流次数越多，也可以选择使用 <a class="link" href="https://juejin.cn/post/7147953172768620575">requestAnimationFrame<i class="fas fa-external-link-alt"></i></a>（请求动画帧），将不会进行重绘和回流</p>
</li>
</ul>
<p>…</p>
<p>总之：回流的性能消耗要比重绘大，能重绘就不回流，能不重绘就不重绘</p>
]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>数组的操作方法合集(2)</title>
    <url>/2021/09/20/%E6%95%B0%E7%BB%84%E7%9A%84%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%952/</url>
    <content><![CDATA[<h3 id="不改变原数组的方法-8个"><a href="#不改变原数组的方法-8个" class="headerlink" title="不改变原数组的方法(8个):"></a><strong>不改变原数组的方法(8个):</strong></h3><div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title class_">ES5</span>：</span><br><span class="line">    slice、join、toLocateString、toStrigin、cancat、indexOf、lastIndexOf、</span><br><span class="line">    <span class="title class_">ES7</span>：</span><br><span class="line">    includes</span><br></pre></td></tr></table></figure></div>

<h4 id="slice-浅拷贝数组的元素"><a href="#slice-浅拷贝数组的元素" class="headerlink" title="slice() 浅拷贝数组的元素"></a><strong>slice() 浅拷贝数组的元素</strong></h4><p>定义： 方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象，且原数组不会被修改。</p>
<p><strong>注意</strong>：字符串也有一个slice() 方法是用来提取字符串的，不要弄混了。</p>
<p>语法:</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">slice</span>(begin, end);</span><br></pre></td></tr></table></figure></div>

<p>begin(可选): 索引数值,接受负值，从该索引处开始提取原数组中的元素,默认值为0。</p>
<p>end(可选):索引数值(不包括),接受负值，在该索引处前结束提取原数组元素，默认值为数组末尾(包括最后一个元素)。</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a= [<span class="string">&#x27;hello&#x27;</span>,<span class="string">&#x27;world&#x27;</span>];</span><br><span class="line">    <span class="keyword">let</span> b=a.<span class="title function_">slice</span>(<span class="number">0</span>,<span class="number">1</span>); <span class="comment">// [&#x27;hello&#x27;]</span></span><br><span class="line">    a[<span class="number">0</span>]=<span class="string">&#x27;改变原数组&#x27;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a,b); <span class="comment">// [&#x27;改变原数组&#x27;,&#x27;world&#x27;] [&#x27;hello&#x27;]</span></span><br><span class="line">    b[<span class="number">0</span>]=<span class="string">&#x27;改变拷贝的数组&#x27;</span>;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(a,b); <span class="comment">// [&#x27;改变原数组&#x27;,&#x27;world&#x27;] [&#x27;改变拷贝的数组&#x27;]</span></span><br></pre></td></tr></table></figure></div>

<p>如上：新数组是浅拷贝的，<strong>元素是简单数据类型，改变之后不会互相干扰</strong></p>
<p>如果是<strong>复杂数据类型(对象,数组)的话，改变其中一个，另外一个也会改变</strong></p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a= [&#123;<span class="attr">name</span>:<span class="string">&#x27;OBKoro1&#x27;</span>&#125;];</span><br><span class="line">    <span class="keyword">let</span> b=a.<span class="title function_">slice</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(b,a); <span class="comment">// [&#123;&quot;name&quot;:&quot;OBKoro1&quot;&#125;]  [&#123;&quot;name&quot;:&quot;OBKoro1&quot;&#125;]</span></span><br><span class="line">    <span class="comment">// a[0].name=&#x27;改变原数组&#x27;;</span></span><br><span class="line">    <span class="comment">// console.log(b,a); // [&#123;&quot;name&quot;:&quot;改变原数组&quot;&#125;] [&#123;&quot;name&quot;:&quot;改变原数组&quot;&#125;]</span></span><br><span class="line">    <span class="comment">// b[0].name=&#x27;改变拷贝数组&#x27;,b[0].koro=&#x27;改变拷贝数组&#x27;;</span></span><br><span class="line">    <span class="comment">//  [&#123;&quot;name&quot;:&quot;改变拷贝数组&quot;,&quot;koro&quot;:&quot;改变拷贝数组&quot;&#125;] [&#123;&quot;name&quot;:&quot;改变拷贝数组&quot;,&quot;koro&quot;:&quot;改变拷贝数组&quot;&#125;]</span></span><br></pre></td></tr></table></figure></div>

<h4 id="join-数组转字符串"><a href="#join-数组转字符串" class="headerlink" title="join() 数组转字符串"></a><strong>join() 数组转字符串</strong></h4><p>定义: join() 方法用于把数组中的所有元素通过指定的分隔符进行分隔放入一个字符串，返回生成的字符串。</p>
<p>语法:</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">join</span>(str)</span><br></pre></td></tr></table></figure></div>

<p>参数:str(可选): 指定要使用的分隔符，默认使用逗号作为分隔符。</p>
<blockquote>
<p>使用join方法或者下文说到的toString方法时，当数组中的元素也是数组或者是对象时会出现什么情况？</p>
</blockquote>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a= [[<span class="string">&#x27;OBKoro1&#x27;</span>,<span class="string">&#x27;23&#x27;</span>],<span class="string">&#x27;test&#x27;</span>];</span><br><span class="line">    <span class="keyword">let</span> str1=a.<span class="title function_">join</span>(); <span class="comment">// OBKoro1,23,test</span></span><br><span class="line">    <span class="keyword">let</span> b= [&#123;<span class="attr">name</span>:<span class="string">&#x27;OBKoro1&#x27;</span>,<span class="attr">age</span>:<span class="string">&#x27;23&#x27;</span>&#125;,<span class="string">&#x27;test&#x27;</span>];</span><br><span class="line">    <span class="keyword">let</span> str2 = b.<span class="title function_">join</span>(); <span class="comment">// [object Object],test</span></span><br><span class="line">    <span class="comment">// 对象转字符串推荐JSON.stringify(obj);</span></span><br></pre></td></tr></table></figure></div>

<p>所以，<code>join()/toString()</code>方法在数组元素是数组的时候，会将里面的数组也调用<code>join()/toString()</code>,如果是对象的话，对象会被转为<code>[object Object]</code>字符串。</p>
<h4 id="toLocaleString-数组转字符串"><a href="#toLocaleString-数组转字符串" class="headerlink" title="toLocaleString() 数组转字符串"></a><strong>toLocaleString() 数组转字符串</strong></h4><p>定义: 返回一个表示数组元素的字符串。该字符串由数组中的每个元素的 toLocaleString() 返回值经调用 join() 方法连接（由逗号隔开）组成。</p>
<p>语法:</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">toLocaleString</span>()</span><br></pre></td></tr></table></figure></div>

<p>参数：无</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a=[&#123;<span class="attr">name</span>:<span class="string">&#x27;OBKoro1&#x27;</span>&#125;,<span class="number">23</span>,<span class="string">&#x27;abcd&#x27;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>()];</span><br><span class="line"><span class="keyword">let</span> str=a.<span class="title function_">toLocaleString</span>(); <span class="comment">// [object Object],23,abcd,2018/5/28 下午1:52:20</span></span><br></pre></td></tr></table></figure></div>

<p>如上述栗子：调用数组的<code>toLocaleString</code>方法，数组中的每个元素都会调用自身的<code>toLocaleString</code>方法，对象调用对象的<code>toLocaleString</code>Date调用Date的<code>toLocaleString</code></p>
<h4 id="toString-数组转字符串-不推荐"><a href="#toString-数组转字符串-不推荐" class="headerlink" title="toString() 数组转字符串 不推荐"></a><strong>toString() 数组转字符串 不推荐</strong></h4><p>该方法的效果和join方法一样，都是用于数组转字符串的，但是与join方法相比没有优势，也不能自定义字符串的分隔符，因此不推荐使用。</p>
<h4 id="cancat-合并两个或多个数组"><a href="#cancat-合并两个或多个数组" class="headerlink" title="cancat 合并两个或多个数组"></a><strong>cancat 合并两个或多个数组</strong></h4><p>定义： 方法用于合并两个或多个数组，返回一个新数组。</p>
<p>语法：</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newArr =oldArray.<span class="title function_">concat</span>(arrayX,arrayX,......,arrayX)</span><br></pre></td></tr></table></figure></div>

<p>参数：</p>
<p>arrayX（必须）：该参数可以是具体的值，也可以是数组对象。可以是任意多个。</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> b = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">    <span class="comment">//连接两个数组</span></span><br><span class="line">    <span class="keyword">let</span> newVal=a.<span class="title function_">concat</span>(b); <span class="comment">// [1,2,3,4,5,6]</span></span><br><span class="line">    <span class="comment">// 连接三个数组</span></span><br><span class="line">    <span class="keyword">let</span> c = [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">    <span class="keyword">let</span> newVal2 = a.<span class="title function_">concat</span>(b, c); <span class="comment">// [1,2,3,4,5,6,7,8,9]</span></span><br><span class="line">    <span class="comment">// 添加元素</span></span><br><span class="line">    <span class="keyword">let</span> newVal3 = a.<span class="title function_">concat</span>(<span class="string">&#x27;添加元素&#x27;</span>,b, c,<span class="string">&#x27;再加一个&#x27;</span>); </span><br><span class="line">    <span class="comment">// [1,2,3,&quot;添加元素&quot;,4,5,6,7,8,9,&quot;再加一个&quot;]</span></span><br><span class="line">   <span class="comment">// 合并嵌套数组  会浅拷贝嵌套数组</span></span><br><span class="line">   <span class="keyword">let</span> d = [<span class="number">1</span>,<span class="number">2</span> ];</span><br><span class="line">   <span class="keyword">let</span> f = [<span class="number">3</span>,[<span class="number">4</span>]];</span><br><span class="line">   <span class="keyword">let</span> newVal4 = d.<span class="title function_">concat</span>(f); <span class="comment">// [1,2,3,[4]]</span></span><br></pre></td></tr></table></figure></div>

<h4 id="ES6扩展运算符-合并数组"><a href="#ES6扩展运算符-合并数组" class="headerlink" title="ES6扩展运算符...合并数组"></a><strong>ES6扩展运算符<code>...</code>合并数组</strong></h4><p>因为ES6的语法更简洁易懂，所以现在合并数组我大部分用<code>...</code> 来处理，<code>...</code>运算符可以实现<code>cancat</code>的每个栗子，且更简洁和具有高度自定义数组元素位置的效果。</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">    <span class="keyword">let</span> b = [ <span class="number">4</span>,...a, <span class="number">4</span>, <span class="number">4</span>]</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a,b); <span class="comment">//  [2, 3, 4, 5] [4,2,3,4,5,4,4]</span></span><br></pre></td></tr></table></figure></div>

<h4 id="indexOf-查找数组是否存在某个元素，返回下标"><a href="#indexOf-查找数组是否存在某个元素，返回下标" class="headerlink" title="indexOf() 查找数组是否存在某个元素，返回下标"></a><strong>indexOf() 查找数组是否存在某个元素，返回下标</strong></h4><p>定义: 返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。</p>
<p>语法:</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">indexOf</span>(searchElement,fromIndex)</span><br></pre></td></tr></table></figure></div>

<p>参数:</p>
<p>searchElement(必须):被查找的元素</p>
<p>fromIndex(可选):开始查找的位置(不能大于等于数组的长度，返回-1)，接受负值，默认值为0。</p>
<p>严格相等的搜索:</p>
<p>数组的indexOf搜索跟字符串的indexOf不一样,数组的indexOf使用严格相等<code>===</code>搜索元素，即<strong>数组元素要完全匹配</strong>才能搜索成功。</p>
<p><strong>注意</strong>：indexOf()不能识别<code>NaN</code></p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a=[<span class="string">&#x27;啦啦&#x27;</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">24</span>,<span class="title class_">NaN</span>]</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">indexOf</span>(<span class="string">&#x27;啦&#x27;</span>));  <span class="comment">// -1 </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">indexOf</span>(<span class="string">&#x27;NaN&#x27;</span>));  <span class="comment">// -1 </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">indexOf</span>(<span class="string">&#x27;啦啦&#x27;</span>)); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></div>

<p>使用场景：</p>
<ol>
<li>数组去重</li>
<li>根据获取的数组下标执行操作，改变数组中的值等。</li>
<li>判断是否存在，执行操作。</li>
</ol>
<h4 id="lastIndexOf-查找指定元素在数组中的最后一个位置"><a href="#lastIndexOf-查找指定元素在数组中的最后一个位置" class="headerlink" title="lastIndexOf() 查找指定元素在数组中的最后一个位置"></a><strong>lastIndexOf() 查找指定元素在数组中的最后一个位置</strong></h4><p>定义: 方法返回指定元素,在数组中的最后一个的索引，如果不存在则返回 -1。（从数组后面往前查找）</p>
<p>语法:</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line">arr.<span class="title function_">lastIndexOf</span>(searchElement,fromIndex)</span><br></pre></td></tr></table></figure></div>

<p>参数:</p>
<p>searchElement(必须): 被查找的元素</p>
<p>fromIndex(可选): 逆向查找开始位置，默认值数组的长度-1，即查找整个数组。</p>
<p>关于fromIndex有三个规则:</p>
<ol>
<li>正值。如果该值大于或等于数组的长度，则整个数组会被查找。</li>
<li>负值。将其视为从数组末尾向前的偏移。(比如-2，从数组最后第二个元素开始往前查找)</li>
<li>负值。其绝对值大于数组长度，则方法返回 -1，即数组不会被查找。</li>
</ol>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a=[<span class="string">&#x27;OB&#x27;</span>,<span class="number">4</span>,<span class="string">&#x27;Koro1&#x27;</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="string">&#x27;Koro1&#x27;</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="string">&#x27;Koro1&#x27;</span>]; <span class="comment">// 数组长度为10</span></span><br><span class="line"> <span class="comment">// let b=a.lastIndexOf(&#x27;Koro1&#x27;,4); // 从下标4开始往前找 返回下标2</span></span><br><span class="line"> <span class="comment">// let b=a.lastIndexOf(&#x27;Koro1&#x27;,100); //  大于或数组的长度 查找整个数组 返回9</span></span><br><span class="line"> <span class="comment">// let b=a.lastIndexOf(&#x27;Koro1&#x27;,-11); // -1 数组不会被查找</span></span><br><span class="line"> <span class="keyword">let</span> b=a.<span class="title function_">lastIndexOf</span>(<span class="string">&#x27;Koro1&#x27;</span>,-<span class="number">9</span>); <span class="comment">// 从第二个元素4往前查找，没有找到 返回-1</span></span><br></pre></td></tr></table></figure></div>

<h4 id="ES7-includes-查找数组是否包含某个元素-返回布尔"><a href="#ES7-includes-查找数组是否包含某个元素-返回布尔" class="headerlink" title="ES7 includes() 查找数组是否包含某个元素 返回布尔"></a><strong>ES7 includes() 查找数组是否包含某个元素 返回布尔</strong></h4><p>定义： 返回一个布尔值，表示某个数组是否包含给定的值</p>
<p>语法：</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">includes</span>(searchElement,fromIndex=<span class="number">0</span>)</span><br></pre></td></tr></table></figure></div>

<p>参数：</p>
<p>searchElement(必须):被查找的元素</p>
<p>fromIndex(可选):默认值为0，参数表示搜索的起始位置，接受负值。正值超过数组长度，数组不会被搜索，返回false。负值绝对值超过长数组度，重置从0开始搜索。</p>
<p><strong>includes方法是为了弥补indexOf方法的缺陷而出现的:</strong></p>
<ol>
<li>indexOf方法不能识别<code>NaN</code></li>
<li>indexOf方法检查是否包含某个值不够语义化，需要判断是否不等于<code>1</code>，表达不够直观</li>
</ol>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a=[<span class="string">&#x27;OB&#x27;</span>,<span class="string">&#x27;Koro1&#x27;</span>,<span class="number">1</span>,<span class="title class_">NaN</span>];</span><br><span class="line">    <span class="comment">// let b=a.includes(NaN); // true 识别NaN</span></span><br><span class="line">    <span class="comment">// let b=a.includes(&#x27;Koro1&#x27;,100); // false 超过数组长度 不搜索</span></span><br><span class="line">    <span class="comment">// let b=a.includes(&#x27;Koro1&#x27;,-3);  // true 从倒数第三个元素开始搜索 </span></span><br><span class="line">    <span class="comment">// let b=a.includes(&#x27;Koro1&#x27;,-100);  // true 负值绝对值超过数组长度，搜索整个数组</span></span><br></pre></td></tr></table></figure></div>

<p>兼容性(MDN): chrome47, Firefox 43,Edge 14,Opera 34, Safari 9,IE 未实现。</p>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾回收</title>
    <url>/2020/01/17/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>数组的操作方法合集(3)</title>
    <url>/2021/09/30/%E6%95%B0%E7%BB%84%E7%9A%84%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%953/</url>
    <content><![CDATA[<h3 id="遍历数组方法-12个"><a href="#遍历数组方法-12个" class="headerlink" title="遍历数组方法(12个):"></a><strong>遍历数组方法(12个):</strong></h3><p>js中遍历数组并不会改变原始数组的方法总共有12个:</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title class_">ES5</span>：</span><br><span class="line">    forEach、every 、some、 filter、map、reduce、reduceRight、</span><br><span class="line">    <span class="title class_">ES6</span>：</span><br><span class="line">    find、findIndex、keys、values、entries</span><br></pre></td></tr></table></figure></div>

<h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a><strong>forEach</strong></h4><p>定义: 按升序为数组中含有效值的每一项执行一次回调函数。</p>
<p>语法：</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>), thisValue)</span><br></pre></td></tr></table></figure></div>

<p>参数:</p>
<p>function(必须): 数组中每个元素需要调用的函数。</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 回调函数的参数</span></span><br><span class="line">    <span class="number">1.</span> <span class="title function_">currentValue</span>(必须),数组当前元素的值</span><br><span class="line">    <span class="number">2.</span> <span class="title function_">index</span>(可选), 当前元素的索引值</span><br><span class="line">    <span class="number">3.</span> <span class="title function_">arr</span>(可选),数组对象本身</span><br></pre></td></tr></table></figure></div>

<p>thisValue(可选): 当执行回调函数时this绑定对象的值，默认值为<code>undefined</code></p>
<p><strong>关于forEach()你要知道</strong></p>
<ul>
<li>无法中途退出循环，只能用<code>return</code>退出本次回调，进行下一次回调。</li>
<li>它总是返回 undefined值,即使你return了一个值。</li>
</ul>
<p><strong>下面类似语法同样适用这些规则</strong></p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 对于空数组是不会执行回调函数的</span><br><span class="line"><span class="number">2.</span> 对于已在迭代过程中删除的元素，或者空元素会跳过回调函数</span><br><span class="line"><span class="number">3.</span> 遍历次数再第一次循环前就会确定，再添加到数组中的元素不会被遍历。</span><br><span class="line"><span class="number">4.</span> 如果已经存在的值被改变，则传递给 callback 的值是遍历到他们那一刻的值。</span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, ,<span class="number">3</span>]; <span class="comment">// 最后第二个元素是空的，不会遍历(undefined、null会遍历)</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;OBKoro1&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> result = a.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">value, index, array</span>) &#123; </span><br><span class="line">a[<span class="number">3</span>] = <span class="string">&#x27;改变元素&#x27;</span>;</span><br><span class="line">a.<span class="title function_">push</span>(<span class="string">&#x27;添加到尾端，不会被遍历&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(value, <span class="string">&#x27;forEach传递的第一个参数&#x27;</span>); <span class="comment">// 分别打印 1 ,2 ,改变元素</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); <span class="comment">// OBKoro1 打印三次 this绑定在obj对象上</span></span><br><span class="line"><span class="comment">// break; // break会报错</span></span><br><span class="line"><span class="keyword">return</span> value; <span class="comment">// return只能结束本次回调 会执行下次回调</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;不会执行，因为return 会执行下一次循环回调&#x27;</span>)</span><br><span class="line">    &#125;, obj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 即使return了一个值,也还是返回undefined</span></span><br><span class="line"><span class="comment">// 回调函数也接受接头函数写法</span></span><br></pre></td></tr></table></figure></div>

<h4 id="every-检测数组所有元素是否都符合判断条件"><a href="#every-检测数组所有元素是否都符合判断条件" class="headerlink" title="every 检测数组所有元素是否都符合判断条件"></a><strong>every 检测数组所有元素是否都符合判断条件</strong></h4><p>定义: 方法用于检测数组所有元素是否都符合函数定义的条件</p>
<p>语法：</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">every</span>(<span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>), thisValue)</span><br></pre></td></tr></table></figure></div>

<p>参数:(这几个方法的参数，语法都类似)</p>
<p>function(必须): 数组中每个元素需要调用的函数。</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 回调函数的参数</span></span><br><span class="line">    <span class="number">1.</span> <span class="title function_">currentValue</span>(必须),数组当前元素的值</span><br><span class="line">    <span class="number">2.</span> <span class="title function_">index</span>(可选), 当前元素的索引值</span><br><span class="line">    <span class="number">3.</span> <span class="title function_">arr</span>(可选),数组对象本身</span><br></pre></td></tr></table></figure></div>

<p>thisValue(可选): 当执行回调函数时this绑定对象的值，默认值为<code>undefined</code></p>
<p>方法返回值规则:</p>
<ol>
<li>如果数组中检测到<strong>有一个元素不满足，则整个表达式返回 false</strong>，且剩余的元素不会再进行检测。</li>
<li>如果所有元素<strong>都满足条件，则返回 true</strong>。&#x3D;</li>
</ol>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isBigEnough</span>(<span class="params">element, index, array</span>) &#123; </span><br><span class="line">      <span class="keyword">return</span> element &gt;= <span class="number">10</span>; <span class="comment">// 判断数组中的所有元素是否都大于10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result = [<span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>].<span class="title function_">every</span>(isBigEnough);   <span class="comment">// false</span></span><br><span class="line">    <span class="keyword">let</span> result = [<span class="number">12</span>, <span class="number">54</span>, <span class="number">18</span>, <span class="number">130</span>, <span class="number">44</span>].<span class="title function_">every</span>(isBigEnough); <span class="comment">// true</span></span><br><span class="line">    <span class="comment">// 接受箭头函数写法 </span></span><br><span class="line">    [<span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>].<span class="title function_">every</span>(<span class="function"><span class="params">x</span> =&gt;</span> x &gt;= <span class="number">10</span>); <span class="comment">// false</span></span><br><span class="line">    [<span class="number">12</span>, <span class="number">54</span>, <span class="number">18</span>, <span class="number">130</span>, <span class="number">44</span>].<span class="title function_">every</span>(<span class="function"><span class="params">x</span> =&gt;</span> x &gt;= <span class="number">10</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>

<h4 id="some-数组中的是否有满足判断条件的元素"><a href="#some-数组中的是否有满足判断条件的元素" class="headerlink" title="some 数组中的是否有满足判断条件的元素"></a><strong>some 数组中的是否有满足判断条件的元素</strong></h4><p>定义：数组中的是否有满足判断条件的元素</p>
<p>语法：</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">some</span>(<span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>), thisValue)</span><br></pre></td></tr></table></figure></div>

<p>参数:(这几个方法的参数，语法都类似)</p>
<p>function(必须): 数组中每个元素需要调用的函数。</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 回调函数的参数</span></span><br><span class="line">    <span class="number">1.</span> <span class="title function_">currentValue</span>(必须),数组当前元素的值</span><br><span class="line">    <span class="number">2.</span> <span class="title function_">index</span>(可选), 当前元素的索引值</span><br><span class="line">    <span class="number">3.</span> <span class="title function_">arr</span>(可选),数组对象本身</span><br></pre></td></tr></table></figure></div>

<p>thisValue(可选): 当执行回调函数时this绑定对象的值，默认值为<code>undefined</code></p>
<p>方法返回值规则：</p>
<ol>
<li>如果<strong>有一个元素满足条件，则表达式返回true</strong>, 剩余的元素不会再执行检测。</li>
<li>如果<strong>没有满足条件的元素，则返回false</strong>。</li>
</ol>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isBigEnough</span>(<span class="params">element, index, array</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> (element &gt;= <span class="number">10</span>); <span class="comment">//数组中是否有一个元素大于 10</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">let</span> result = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>].<span class="title function_">some</span>(isBigEnough); <span class="comment">// false</span></span><br><span class="line"> <span class="keyword">let</span> result = [<span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>].<span class="title function_">some</span>(isBigEnough); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>

<h4 id="filter-过滤原始数组，返回新数组"><a href="#filter-过滤原始数组，返回新数组" class="headerlink" title="filter 过滤原始数组，返回新数组"></a><strong>filter 过滤原始数组，返回新数组</strong></h4><p>定义: 返回一个新数组, 其包含通过所提供函数实现的测试的所有元素。</p>
<p>语法：</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> new_array = arr.<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>), thisArg</span><br></pre></td></tr></table></figure></div>

<p>参数:(这几个方法的参数，语法都类似)</p>
<p>function(必须): 数组中每个元素需要调用的函数。</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 回调函数的参数</span></span><br><span class="line"><span class="number">1.</span> <span class="title function_">currentValue</span>(必须),数组当前元素的值</span><br><span class="line"><span class="number">2.</span> <span class="title function_">index</span>(可选), 当前元素的索引值</span><br><span class="line"><span class="number">3.</span> <span class="title function_">arr</span>(可选),数组对象本身</span><br></pre></td></tr></table></figure></div>

<p>thisValue(可选):  当执行回调函数时this绑定对象的值，默认值为<code>undefined</code></p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">32</span>, <span class="number">33</span>, <span class="number">16</span>, <span class="number">40</span>];</span><br><span class="line"><span class="keyword">let</span> result = a.<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">value, index, array</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> value &gt;= <span class="number">18</span>; <span class="comment">// 返回a数组中所有大于18的元素</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result,a);<span class="comment">// [32,33,40] [32,33,16,40]</span></span><br></pre></td></tr></table></figure></div>

<h4 id="map-对数组中的每个元素进行处理，返回新的数组"><a href="#map-对数组中的每个元素进行处理，返回新的数组" class="headerlink" title="map 对数组中的每个元素进行处理，返回新的数组"></a>map 对数组中的每个元素进行处理，返回新的数组</h4><p>定义：创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</p>
<p>语法：</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> new_array = arr.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>), thisArg)</span><br></pre></td></tr></table></figure></div>

<p>参数:(这几个方法的参数，语法都类似)</p>
<p>function(必须): 数组中每个元素需要调用的函数。</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 回调函数的参数</span></span><br><span class="line"><span class="number">1.</span> <span class="title function_">currentValue</span>(必须),数组当前元素的值</span><br><span class="line"><span class="number">2.</span> <span class="title function_">index</span>(可选), 当前元素的索引值</span><br><span class="line"><span class="number">3.</span> <span class="title function_">arr</span>(可选),数组对象本身</span><br></pre></td></tr></table></figure></div>

<p>thisValue(可选):  当执行回调函数时this绑定对象的值，默认值为<code>undefined</code></p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> result = a.<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">value, index, array</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> value + <span class="string">&#x27;新数组的新元素&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result, a);</span><br><span class="line"><span class="comment">// [&quot;1新数组的新元素&quot;,&quot;2新数组的新元素&quot;,&quot;3新数组的新元素&quot;,&quot;4新数组的新元素&quot;] [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;]</span></span><br></pre></td></tr></table></figure></div>

<h4 id="reduce-为数组提供累加器，合并为一个值"><a href="#reduce-为数组提供累加器，合并为一个值" class="headerlink" title="reduce 为数组提供累加器，合并为一个值"></a>reduce 为数组提供累加器，合并为一个值</h4><p>定义：reduce() 方法对累加器和数组中的每个元素（从左到右）应用一个函数，最终合并为一个值。</p>
<p>语法：</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">reduce</span>(<span class="keyword">function</span>(<span class="params">total, currentValue, currentIndex, arr</span>), initialValue)</span><br></pre></td></tr></table></figure></div>

<p>参数：</p>
<p>function(必须): 数组中每个元素需要调用的函数。</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 回调函数的参数</span></span><br><span class="line"><span class="number">1.</span> <span class="title function_">total</span>(必须)，初始值, 或者上一次调用回调返回的值</span><br><span class="line"><span class="number">2.</span> <span class="title function_">currentValue</span>(必须),数组当前元素的值</span><br><span class="line"><span class="number">3.</span> <span class="title function_">index</span>(可选), 当前元素的索引值</span><br><span class="line"><span class="number">4.</span> <span class="title function_">arr</span>(可选),数组对象本身</span><br></pre></td></tr></table></figure></div>

<p>initialValue(可选): 指定第一次回调 的第一个参数。</p>
<p>回调第一次执行时:</p>
<ul>
<li>如果 initialValue 在调用 reduce 时被提供，那么第一个 total 将等于 initialValue，此时 currentValue 等于数组中的第一个值；</li>
<li>如果 initialValue 未被提供，那么 total 等于数组中的第一个值，currentValue 等于数组中的第二个值。此时如果数组为空，那么将抛出 TypeError。</li>
<li>如果数组仅有一个元素，并且没有提供 initialValue，或提供了 initialValue 但数组为空，那么回调不会被执行，数组的唯一值将被返回。</li>
</ul>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组求和</span></span><br><span class="line"><span class="keyword">let</span> sum = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">reduce</span>(<span class="keyword">function</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 将二维数组转化为一维 将数组元素展开</span></span><br><span class="line"><span class="keyword">let</span> flattened = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]].<span class="title function_">reduce</span>(</span><br><span class="line">  <span class="function">(<span class="params">a, b</span>) =&gt;</span> a.<span class="title function_">concat</span>(b),</span><br><span class="line">  []</span><br><span class="line">);</span><br><span class="line"> <span class="comment">// [0, 1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></div>

<h4 id="reduceRight-从右至左累加"><a href="#reduceRight-从右至左累加" class="headerlink" title="reduceRight 从右至左累加"></a>reduceRight 从右至左累加</h4><p>这个方法除了与reduce执行方向相反外，其他完全与其一致，请参考上述 reduce 方法介绍。</p>
<h4 id="ES6：find-amp-findIndex-根据条件找到数组成员"><a href="#ES6：find-amp-findIndex-根据条件找到数组成员" class="headerlink" title="ES6：find()&amp; findIndex() 根据条件找到数组成员"></a>ES6：find()&amp; findIndex() 根据条件找到数组成员</h4><p>find()定义：用于找出第一个符合条件的数组成员，并返回该成员，如果没有符合条件的成员，则返回undefined。</p>
<p>findIndex()定义：返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。</p>
<p>这两个方法</p>
<p>语法：</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> new_array = arr.<span class="title function_">find</span>(<span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>), thisArg)</span><br><span class="line"> <span class="keyword">let</span> new_array = arr.<span class="title function_">findIndex</span>(<span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>), thisArg)</span><br></pre></td></tr></table></figure></div>

<p>参数:(这几个方法的参数，语法都类似)</p>
<p>function(必须): 数组中每个元素需要调用的函数。</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 回调函数的参数</span></span><br><span class="line"><span class="number">1.</span> <span class="title function_">currentValue</span>(必须),数组当前元素的值</span><br><span class="line"><span class="number">2.</span> <span class="title function_">index</span>(可选), 当前元素的索引值</span><br><span class="line"><span class="number">3.</span> <span class="title function_">arr</span>(可选),数组对象本身</span><br></pre></td></tr></table></figure></div>

<p>thisValue(可选):  当执行回调函数时this绑定对象的值，默认值为<code>undefined</code></p>
<p>这两个方法都可以识别<code>NaN</code>,弥补了<code>indexOf</code>的不足.</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// find</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">4</span>, -<span class="number">5</span>, <span class="number">10</span>].<span class="title function_">find</span>(<span class="function">(<span class="params">n</span>) =&gt;</span> n &lt; <span class="number">0</span>); <span class="comment">// 返回元素-5</span></span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">1</span>, <span class="number">4</span>, -<span class="number">5</span>, <span class="number">10</span>,<span class="title class_">NaN</span>].<span class="title function_">find</span>(<span class="function">(<span class="params">n</span>) =&gt;</span> <span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">NaN</span>, n));  <span class="comment">// 返回元素NaN</span></span><br><span class="line"><span class="comment">// findIndex</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">4</span>, -<span class="number">5</span>, <span class="number">10</span>].<span class="title function_">findIndex</span>(<span class="function">(<span class="params">n</span>) =&gt;</span> n &lt; <span class="number">0</span>); <span class="comment">// 返回索引2</span></span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">1</span>, <span class="number">4</span>, -<span class="number">5</span>, <span class="number">10</span>,<span class="title class_">NaN</span>].<span class="title function_">findIndex</span>(<span class="function">(<span class="params">n</span>) =&gt;</span> <span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">NaN</span>, n));  <span class="comment">// 返回索引4</span></span><br></pre></td></tr></table></figure></div>

<p>浏览器兼容(MDN):Chrome 45,Firefox 25,Opera 32, Safari 8, Edge yes,</p>
<h4 id="ES6-keys-amp-values-amp-entries-遍历键名、遍历键值、遍历键名-键值"><a href="#ES6-keys-amp-values-amp-entries-遍历键名、遍历键值、遍历键名-键值" class="headerlink" title="ES6 keys()&amp;values()&amp;entries() 遍历键名、遍历键值、遍历键名+键值"></a>ES6 keys()&amp;values()&amp;entries() 遍历键名、遍历键值、遍历键名+键值</h4><p>定义：三个方法都返回一个新的 Array Iterator 对象，对象根据方法不同包含不同的值。</p>
<p>语法：</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">keys</span>()</span><br><span class="line">array.<span class="title function_">values</span>()</span><br><span class="line">array.<span class="title function_">entries</span>()</span><br></pre></td></tr></table></figure></div>

<p>参数：无。</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">keys</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">values</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(index, elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 &quot;a&quot;</span></span><br><span class="line"><span class="comment">// 1 &quot;b&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>在<code>for..of</code>中如果遍历中途要退出，可以使用<code>break</code>退出循环。</p>
<p>如果不使用<code>for...of</code>循环，可以手动调用遍历器对象的next方法，进行遍历:</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> letter = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> entries = letter.<span class="title function_">entries</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(entries.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// [0, &#x27;a&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(entries.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// [1, &#x27;b&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(entries.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// [2, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure></div>

<p>entries()浏览器兼容性(MDN):Chrome 38, Firefox 28,Opera 25,Safari 7.1</p>
<p>keys()浏览器兼容性(MDN):Chrome 38, Firefox 28,Opera 25,Safari 8,</p>
<p><strong>注意</strong>:目前只有Safari 9支持,，其他浏览器未实现，babel转码器也还未实现</p>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>数组的操作方法合集(4）</title>
    <url>/2021/09/30/%E6%95%B0%E7%BB%84%E7%9A%84%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%954/</url>
    <content><![CDATA[<p><img lazyload src="/images/loading.svg" data-src="/../img/%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95.png" alt="数组的常见操作方法.png"></p>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>继承</title>
    <url>/2022/11/17/%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>箭头函数</title>
    <url>/2020/12/07/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p><strong>在ES6中 允许使用“箭头”（&#x3D;&gt;）定义函数，称为 箭头函数。</strong></p>
<h4 id="箭头函数的写法"><a href="#箭头函数的写法" class="headerlink" title="箭头函数的写法"></a>箭头函数的写法</h4><ol>
<li>箭头函数 基本语法</li>
</ol>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">123</span>)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn1</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">123</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn1</span>()</span><br><span class="line"><span class="comment">// 传参</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn2</span> = (<span class="params">x</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn2</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>只有一个形参的时候，可以省略小括号</li>
</ol>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fn3</span> = x =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn3</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li>只有一行代码的时候，我们可以省略大括号</li>
</ol>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fn4</span> = x =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(x)</span><br><span class="line"><span class="title function_">fn4</span>(<span class="number">6</span>)</span><br></pre></td></tr></table></figure></div>

<ol start="4">
<li>只有一行代码的时候，可以省略return</li>
</ol>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fn5</span> = x =&gt; x + x</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn5</span>(<span class="number">1</span>))</span><br></pre></td></tr></table></figure></div>

<ol start="5">
<li>箭头函数可以直接返回一个对象, 但必须在对象外面加上括号</li>
</ol>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fn6</span> = (<span class="params">name</span>) =&gt; (&#123; <span class="attr">user_name</span>: name &#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn6</span>(<span class="string">&#x27;刘德华&#x27;</span>))</span><br></pre></td></tr></table></figure></div>



<h4 id="箭头函数参数"><a href="#箭头函数参数" class="headerlink" title="箭头函数参数"></a>箭头函数参数</h4><ol>
<li>普通函数有arguments对象</li>
<li>箭头函数没有arguments对象，但是可以使用剩余参数<code>...args</code></li>
</ol>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求传入参数的总和</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getSum</span> = (<span class="params">...args</span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">	args.<span class="title function_">forEach</span>(<span class="function"><span class="params">el</span> =&gt;</span> &#123;</span><br><span class="line">		 sum += el</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> res = <span class="title function_">getSum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br></pre></td></tr></table></figure></div>



<h4 id="箭头函数this"><a href="#箭头函数this" class="headerlink" title="箭头函数this"></a>箭头函数this</h4><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以前this的指向：  谁调用的这个函数，this 就指向谁</span></span><br><span class="line"><span class="comment">// console.log(this)  // window</span></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)  <span class="comment">// window</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">fn</span>()</span><br><span class="line"><span class="comment">// 对象方法里面的this</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;andy&#x27;</span>,</span><br><span class="line">  <span class="attr">sayHi</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)  <span class="comment">// obj</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">sayHi</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 箭头函数的this  是上一层作用域的this 指向</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)  <span class="comment">// window</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>()</span><br><span class="line"><span class="comment">// 对象方法箭头函数 this</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">uname</span>: <span class="string">&#x27;pink老师&#x27;</span>,</span><br><span class="line">  <span class="attr">sayHi</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)  <span class="comment">// this 指向谁？</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">sayHi</span>()</span><br></pre></td></tr></table></figure></div>



<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li>箭头函数没有自己的this对象</li>
<li>箭头函数不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</li>
<li>箭头函数不可以作为构造函数，也就是不可以对箭头函数使用<code>new</code>命令</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>闭包</title>
    <url>/2020/01/17/%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>深拷贝/浅拷贝</title>
    <url>/2021/03/10/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><p>赋值：将某一个数值或对象赋给某个变量的过程</p>
<ul>
<li><p>基本数据类型：值传递，赋值之后两个变量互不影响</p>
<p><img lazyload src="/images/loading.svg" data-src="/../img/image-20230213195557503.png" alt="image-20230213195557503"></p>
</li>
</ul>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&#x27;大家早上吃饭了吗&#x27;</span></span><br><span class="line"><span class="keyword">let</span> b = a</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>引用数据类型：赋值（地址），两个变量具有相同的引用，指向同一个对象，相互之间有影响</p>
<p><img lazyload src="/images/loading.svg" data-src="/../img/image-20230213195605580.png" alt="image-20230213195605580"></p>
</li>
</ul>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;你不知道的JavaScript 上&#x27;</span>,</span><br><span class="line">    <span class="attr">book</span>:&#123;</span><br><span class="line">        <span class="attr">price</span>:<span class="string">&#x27;300$&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = obj</span><br><span class="line"></span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&#x27;hhh&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">name</span>)</span><br></pre></td></tr></table></figure></div>

<p><strong>赋值不是浅拷贝，没有堆内存中新创建一个对象</strong></p>
<h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><ul>
<li><p><strong>定义</strong>：</p>
<ol>
<li><strong>在堆内存中新开辟一个内存空间，创建一个新对象</strong></li>
<li><strong>新对象只包含被拷贝对象第一层基本数据类型和引用类型的地址</strong></li>
</ol>
<p><img lazyload src="/images/loading.svg" data-src="/../img/image-20230213195612037.png" alt="image-20230213195612037"></p>
</li>
<li><p><strong>注意</strong>：</p>
<ol>
<li>第一层如果是基本数据类型，那么前后两个对象的属性互不影响</li>
<li>第一层如果是引用类型，引用值改变，会相互影响</li>
</ol>
</li>
<li><p><strong>浅拷贝方式</strong>：</p>
<ol>
<li><strong>Object.assign(target,source)</strong></li>
</ol>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj2 = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj1)</span><br><span class="line"><span class="comment">// 第一层，属性值如果是基本数据类型，拷贝前后的两个对象的这个属性互不影响</span></span><br><span class="line">obj2.<span class="property">name</span> = <span class="string">&#x27;java&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">name</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">name</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">name</span> === obj2.<span class="property">name</span>)    <span class="comment">// 基本数据类型判断全等 值和类型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">book</span> === obj2.<span class="property">book</span>)    <span class="comment">// 引用类型，看地址是否一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一层，属性值如果是引用类型，引用类型的值会改变，会相互影响</span></span><br><span class="line">obj1.<span class="property">book</span>.<span class="property">price</span> = <span class="number">56</span></span><br><span class="line"><span class="comment">// console.log(obj2)</span></span><br></pre></td></tr></table></figure></div>



<ol start="2">
<li><strong>对象拓展运算符</strong></li>
</ol>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj3 = &#123; ...obj &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj3)</span><br><span class="line">obj3.<span class="property">name</span> = <span class="string">&#x27;test&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>)</span><br><span class="line"></span><br><span class="line">obj3.<span class="property">book</span>.<span class="property">price</span> = <span class="number">222</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">book</span>.<span class="property">price</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<ol start="3">
<li><strong>Array.prototype.contact()</strong></li>
</ol>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, &#123; <span class="attr">user</span>: <span class="string">&#x27;杰伦&#x27;</span> &#125;]</span><br><span class="line"><span class="keyword">const</span> arr2 = arr1.<span class="title function_">concat</span>()</span><br><span class="line"><span class="comment">// console.log(arr2)</span></span><br><span class="line"></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">666</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2)</span><br><span class="line">arr[<span class="number">2</span>].<span class="property">user</span> = <span class="string">&#x27;磊磊&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<ol start="4">
<li><strong>Array.prototype.slice()</strong></li>
</ol>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr3 = [<span class="number">1</span>, <span class="number">2</span>, &#123; <span class="attr">user</span>: <span class="string">&#x27;杰伦&#x27;</span> &#125;]</span><br><span class="line"><span class="keyword">const</span> arr4 = arr3.<span class="title function_">slice</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr3)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr4)</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><ul>
<li><p><strong>定义：</strong></p>
<ol>
<li><strong>在堆内存中开辟一个新的空间存新的对象</strong></li>
<li><strong>递归的拷贝原对象的属性和方法，拷贝前后的两个对象，互不影响</strong></li>
</ol>
<p><img lazyload src="/images/loading.svg" data-src="/../img/image-20230213195625187.png" alt="image-20230213195625187"></p>
</li>
<li><p><strong>深拷贝方式：</strong></p>
<ol>
<li><p><strong>递归函数</strong></p>
<p>一层一层的，每一层都新创建一个内存空间</p>
</li>
</ol>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;JS&#x27;</span>,</span><br><span class="line">    <span class="attr">book</span>: &#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&quot;you don&#x27;t know JS&quot;</span>,</span><br><span class="line">        <span class="attr">price</span>: <span class="string">&#x27;300$&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a1 = &#123; <span class="attr">b</span>: &#123; <span class="attr">c</span>: &#123;&#125; &#125; &#125;</span><br><span class="line"><span class="keyword">let</span> a2 = &#123; ...a1 &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a1.<span class="property">b</span>.<span class="property">c</span> === a2.<span class="property">b</span>.<span class="property">c</span>)</span><br><span class="line"><span class="comment">// 浅拷贝：新旧对象共享同一块内存空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 深拷贝 </span></span><br><span class="line"><span class="keyword">let</span> a3 = <span class="title function_">deepClone</span>(a1)  <span class="comment">// deepClone表示深拷贝的一些方法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a3.<span class="property">b</span>.<span class="property">c</span> === a1.<span class="property">b</span>.<span class="property">c</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure></div>

<p><strong>递归： 自己调用自己  有递  有归</strong></p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">num</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(num === <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num + <span class="title function_">fn</span>(num - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>(<span class="number">3</span>)  <span class="comment">// ==&gt; 3 + fn(2)  ==&gt; 3 + 2 + fn(1)  ==&gt; 3 + 2 + 1 ==&gt; 6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn</span>(<span class="number">3</span>))  <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>(<span class="number">5</span>)  <span class="comment">// ==&gt;  5 + fn(4) ==&gt;  5 + 4 + fn(3) ==&gt; 5 + 4 + 3 + fn(2) ==&gt; 5 + 4 + 3 + 2 + fn(1) </span></span><br><span class="line"><span class="comment">//   5 + 4 + 3 + 2 + 1  ==&gt; 15 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn</span>(<span class="number">5</span>))</span><br></pre></td></tr></table></figure></div>

<p><strong>递归的问题：</strong>递归爆栈（栈溢出）</p>
<p>栈 &#x3D;&#x3D;&#x3D;&gt; 数据结构， 有先进后出的特征， 栈有深度， 如果超出了， 就会造成栈溢出报错</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">let</span> <span class="variable">res</span> <span class="operator">=</span> fn(<span class="number">10000</span>)</span><br><span class="line">console.log(res)</span><br></pre></td></tr></table></figure></div>

<p>递归也可以看作一种循环（不断的自己调用自己），循环有终止条件，递归也需要有终止条件</p>
<p>递归的终止条件， 一般写在第二次调用的前面，return可以终止函数的执行</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">1</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">count</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`这是第<span class="subst">$&#123;i&#125;</span>次调用`</span>)   </span><br><span class="line">    <span class="keyword">if</span>(i &gt;= <span class="number">1000</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">count</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">count</span>()</span><br></pre></td></tr></table></figure></div>



<ol start="2">
<li><strong>JSON</strong></li>
</ol>
<p>const res &#x3D; JSON.parse(JSON.stringify(obj))</p>
<p>JSON.parse() 将JSON格式的字符串转为对象</p>
<p>JSON.stringify() 将对象转化为JSON格式的字符串</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="variable">obj</span> <span class="operator">=</span> &#123;</span><br><span class="line">    name:<span class="string">&#x27;团团&#x27;</span>,</span><br><span class="line">    age:<span class="number">7</span>,</span><br><span class="line">    hobby:[<span class="string">&#x27;dance&#x27;</span>,<span class="string">&#x27;sing&#x27;</span>],</span><br><span class="line">    book:&#123;</span><br><span class="line">        title:<span class="string">&#x27;JS&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    test1: function()&#123;&#125;,</span><br><span class="line">    test2: undefined,</span><br><span class="line">    test3: Symbol(),</span><br><span class="line">    test4: NaN,</span><br><span class="line">    test5: Infinity,</span><br><span class="line">    test6: <span class="keyword">new</span> <span class="title class_">RegExp</span>(/e/,<span class="string">&#x27;g&#x27;</span>),</span><br><span class="line">    test7: <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">console.log(a)</span><br><span class="line">console.log(typeof a)</span><br><span class="line"><span class="type">const</span> <span class="variable">res</span> <span class="operator">=</span> JSON.parse(JSON,stringify(obj))</span><br></pre></td></tr></table></figure></div>

<p><strong>缺陷：</strong></p>
<ol>
<li>如果拷贝对象的属性值是function，undefined，Symbol，这个键值对会丢失。</li>
<li>如果是NaN和infinity，属性值会变为null。</li>
<li>如果是正则变为空对象。</li>
<li>如果是日期对象会变为字符串。</li>
</ol>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// console.log(res)</span></span><br><span class="line">res.<span class="property">hobby</span>[<span class="number">0</span>] = <span class="string">&#x27;run&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li><strong>lodash库</strong></li>
</ol>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;团团&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>:<span class="number">7</span>,</span><br><span class="line">        <span class="attr">hobby</span>:[<span class="string">&#x27;dance&#x27;</span>,<span class="string">&#x27;sing&#x27;</span>],</span><br><span class="line">        <span class="attr">book</span>:&#123;</span><br><span class="line">            <span class="attr">title</span>:<span class="string">&#x27;JS&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用loadsh库，实现深拷贝</span></span><br><span class="line">    <span class="keyword">const</span> o = _.<span class="title function_">cloneDeep</span>(obj)</span><br><span class="line">    <span class="comment">// console.log(o)</span></span><br><span class="line"></span><br><span class="line">    o.<span class="property">book</span>.<span class="property">title</span> = <span class="string">&#x27;java&#x27;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(o)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj)</span><br></pre></td></tr></table></figure></div></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>防抖节流</title>
    <url>/2020/01/17/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
