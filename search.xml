<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2022/11/17/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link" href="https://hexo.io/">Hexo<i class="fas fa-external-link-alt"></i></a>! This is your very first post. Check <a class="link" href="https://hexo.io/docs/">documentation<i class="fas fa-external-link-alt"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link" href="https://hexo.io/docs/troubleshooting.html">troubleshooting<i class="fas fa-external-link-alt"></i></a> or you can ask me on <a class="link" href="https://github.com/hexojs/hexo/issues">GitHub<i class="fas fa-external-link-alt"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link" href="https://hexo.io/docs/writing.html">Writing<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link" href="https://hexo.io/docs/server.html">Server<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link" href="https://hexo.io/docs/generating.html">Generating<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link" href="https://hexo.io/docs/one-command-deployment.html">Deployment<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>title</title>
    <url>/2022/11/17/title/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>JavaScript中的数据类型</title>
    <url>/2020/06/20/js%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="一、JS中有哪些数据类型"><a href="#一、JS中有哪些数据类型" class="headerlink" title="一、JS中有哪些数据类型"></a>一、JS中有哪些数据类型</h2><p>JS中的数据类型大致分为<strong>基本数据类型</strong>和引用类型</p>
<p><strong>基本数据类型有</strong>：</p>
<ul>
<li>String (字符串）</li>
<li>Number（数字）</li>
<li>Boolean （布尔值）</li>
<li>Undefined （未定义）</li>
<li>null （空值）</li>
<li>Symbol （符号）</li>
<li>Bigint</li>
</ul>
<ol>
<li>其中 <code>string</code> 、<code>number</code> 、<code>boolean</code> 和 <code>null</code> <code>undefined</code> 这五种类型统称为<strong>原始类型</strong>（Primitive），表示不能再细分下去的基本类型;</li>
<li><code>symbol</code>是ES6中新增的数据类型，<code>symbol</code> 表示独一无二的值，最大的用法是用来定义对象的唯一属性名</li>
<li>基本数据类型的值存放在栈中，在栈中存放的是对应的值，赋值时直接赋对应的值</li>
</ol>
<p><strong>引用类型有：</strong>Object 、 Array 、 Function、Data等</p>
<p>引用数据类型的值存放在堆中，在栈中存放的是指向堆内存的地址，赋值时赋的是指向堆内存的地址</p>
<h2 id="二、JS是弱类型语言的理解"><a href="#二、JS是弱类型语言的理解" class="headerlink" title="二、JS是弱类型语言的理解"></a>二、JS是弱类型语言的理解</h2><p>js声明变量的时候并没有预先确定的类型，变量的类型就是这个值的类型，就是说<strong>变量当前的类型由其值所决定</strong>，夸张一点说就是上一秒还是字符串，下一秒可能就是数字类型了，其中可能发生了什么操作进行强制转换了。所以说弱类型的这种<strong>不需要预先确定的类型</strong>的特性能给我们带来便利，也会带来困扰。</p>
<blockquote>
<p><code>javascript</code>中强制类型转换是一个非常易出现<code>bug</code>的点，知道强制转换时候的规则吗？</p>
</blockquote>
<ol>
<li>用<code>ToPrimitive</code>(转换为原始值)，可以把引用类型转换为原始类型</li>
<li>可以接收两个参数</li>
</ol>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line">**</span><br><span class="line">* @obj 需要转换的对象</span><br><span class="line">* @type 期望转换为的原始数据类型，可选</span><br><span class="line">*/</span><br><span class="line"><span class="title class_">ToPrimitive</span>(obj,type)  </span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li><code>Number</code>运算符转换规则：</li>
</ol>
<ul>
<li><p><code>null</code> 转换为 0</p>
</li>
<li><p><code>undefined</code> 转换为 <code>NaN</code></p>
</li>
<li><p><code>true</code> 转换为 1，<code>false</code> 转换为 0</p>
</li>
<li><p>字符串转换时遵循数字常量规则，转换失败返回 <code>NaN</code></p>
</li>
</ul>
<ol start="4">
<li><code>String</code>运算符转换规则:</li>
</ol>
<ul>
<li><p><code>null</code> 转换为 <code>&#39;null&#39;</code></p>
</li>
<li><p><code>undefined</code> 转换为  <code>&#39;undefined&#39;</code></p>
</li>
<li><p><code>true</code> 转换为 <code>&#39;true&#39;</code>，<code>false</code> 转换为 <code>&#39;false&#39;</code></p>
</li>
<li><p>数字转换遵循通用规则，极大极小的数字使用指数形</p>
</li>
</ul>
<ol start="5">
<li><code>ToBoolean</code>运算符转换规则:</li>
</ol>
<p>​	除了下述 6 个值转换结果为 <code>false</code>，其他全部为 <code>true</code>：</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="literal">undefined</span></span><br><span class="line"><span class="number">2.</span> <span class="literal">null</span></span><br><span class="line"><span class="number">3.</span> -<span class="number">0</span></span><br><span class="line"><span class="number">4.</span> <span class="number">0</span>或+<span class="number">0</span></span><br><span class="line"><span class="number">5.</span> <span class="title class_">NaN</span></span><br><span class="line"><span class="number">6.</span> <span class="string">&#x27;&#x27;</span>（空字符串）</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>知道了具体转换成什么的规则，但是都在什么情况下发生什么样的转换呢？(什么情况下会自动转换？）</p>
</blockquote>
<p><strong>什么时候自动转换为string类型</strong></p>
<ul>
<li>在没有对象的前提下,发生在字符串的<strong>加法运算。</strong>当一个值为字符串，另一个值为非字符串，则后者转为字符串。</li>
<li>当有对象且与对象<code>+</code>（正）时候</li>
</ul>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//几种特殊对象</span></span><br><span class="line"><span class="string">&#x27;2&#x27;</span> + &#123;&#125; <span class="comment">// &quot;2[object Object]&quot;</span></span><br><span class="line"><span class="string">&#x27;2&#x27;</span> + [] <span class="comment">// &quot;2&quot;</span></span><br><span class="line"><span class="string">&#x27;2&#x27;</span> + <span class="keyword">function</span> (<span class="params"></span>)&#123;&#125; <span class="comment">// &quot;2function ()&#123;&#125;&quot;</span></span><br><span class="line"><span class="string">&#x27;2&#x27;</span> + [<span class="string">&#x27;koala&#x27;</span>,<span class="number">1</span>] <span class="comment">// 2koala,1</span></span><br></pre></td></tr></table></figure></div>



<p><strong>什么时候自动转换为Number类型</strong></p>
<ul>
<li>有加法运算符，但是无<code>String</code>类型的时候，都会优先转换为<code>Number</code>类型</li>
<li><strong>除了加法运算符，其他运算符都会把运算自动转成数值。</strong></li>
</ul>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一元运算符（注意点）</span></span><br><span class="line">+<span class="string">&#x27;abc&#x27;</span> <span class="comment">// NaN</span></span><br><span class="line">-<span class="string">&#x27;abc&#x27;</span> <span class="comment">// NaN</span></span><br><span class="line">+<span class="literal">true</span> <span class="comment">// 1</span></span><br><span class="line">-<span class="literal">false</span> <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">注意：<span class="literal">null</span>转为数值时为<span class="number">0</span>，而<span class="literal">undefined</span>转为数值时为<span class="title class_">NaN</span>。</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>如何判断数据类型？怎么判断一个值到底是数组类型还是对象?</p>
</blockquote>
<ol>
<li>typeof 检测基本数据类型，返回基本数据类型</li>
<li>instanceof 检测引用数据类型，返回true&#x2F;false</li>
<li>Object.prototype.toString.call() 两个都可以检测，返回数据类型</li>
</ol>
<h2 id="三、typeof与instanceof的区别"><a href="#三、typeof与instanceof的区别" class="headerlink" title="三、typeof与instanceof的区别:"></a>三、typeof与instanceof的区别:</h2><ol>
<li><p>typeof操作符右侧跟一个表达式，并返回该表达式的数据类型；能判断所有的值类型，但判断null，数组，对象都返回object</p>
</li>
<li><p>instanceof运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上，通俗一点就是，只要右边变量的prototype在左边变量的原型链上就返回 true，否则返回 false instanceof能准确判断引用类型，不能判断基本类型</p>
</li>
<li><p>检测数据类型：终极方法 Object.prototype.toString.call(）</p>
</li>
</ol>
<h2 id="四、NaN"><a href="#四、NaN" class="headerlink" title="四、NaN"></a>四、NaN</h2><blockquote>
<p>简单说一下NaN</p>
</blockquote>
<p><code>NaN</code>是一个全局对象的属性，<code>NaN</code>是一种特殊的<code>Number</code>类型。</p>
<p><strong>什么情况下返回NaN：</strong></p>
<ul>
<li>无穷大除以无穷大</li>
<li>给任意负数做开方运算</li>
<li>算数运算符与不是数字或无法转换为数字的操作数一起使用</li>
<li>字符串解析成数字</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Infinity</span> / <span class="title class_">Infinity</span>;   <span class="comment">// 无穷大除以无穷大</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">sqrt</span>(-<span class="number">1</span>);         <span class="comment">// 给任意负数做开方运算</span></span><br><span class="line"><span class="string">&#x27;a&#x27;</span> - <span class="number">1</span>;               <span class="comment">// 算数运算符与不是数字或无法转换为数字的操作数一起使用</span></span><br><span class="line"><span class="string">&#x27;a&#x27;</span> * <span class="number">1</span>;</span><br><span class="line"><span class="string">&#x27;a&#x27;</span> / <span class="number">1</span>;</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;a&#x27;</span>);         <span class="comment">// 字符串解析成数字</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&#x27;a&#x27;</span>);   <span class="comment">//NaN</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span> - <span class="number">1</span>   <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">undefined</span> + <span class="number">1</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="comment">//一元运算符（注意点）</span></span><br><span class="line">+<span class="string">&#x27;abc&#x27;</span> <span class="comment">// NaN</span></span><br><span class="line">-<span class="string">&#x27;abc&#x27;</span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure></div>

]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>test</title>
    <url>/2022/11/17/test/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>第一篇博客</title>
    <url>/2022/09/10/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>关于回流重绘</title>
    <url>/2020/06/06/%E5%9B%9E%E6%B5%81%E9%87%8D%E7%BB%98/</url>
    <content><![CDATA[<h2 id="一-需要先了解一下浏览器的渲染机制"><a href="#一-需要先了解一下浏览器的渲染机制" class="headerlink" title="一.需要先了解一下浏览器的渲染机制"></a>一.需要先了解一下浏览器的渲染机制</h2><p><img lazyload src="/images/loading.svg" data-src="/./img/2022111-160838.jpg" alt="2022111-160838.jpg"></p>
<p>从上面这个图，我们可以看到，浏览器渲染过程如下：</p>
<ol>
<li><p>解析HTML，生成DOM树，解析CSS，生成CSS OM</p>
</li>
<li><p>将DO M树和CSSOM树结合，生成渲染树</p>
</li>
<li><p>回流：根据生成的渲染树进行回流，得到节点的位置，大小等</p>
</li>
<li><p>重绘：根据渲染树以及回流得到的信息进行绘制</p>
</li>
<li><p>最后展示在页面上</p>
<p> <strong>回流一定会引起重绘，重绘不一定会引起回流</strong></p>
</li>
</ol>
<p>看一下DOM树和CSSOM树是怎么样合成为渲染树的</p>
<p><img lazyload src="/images/loading.svg" data-src="/./img/49d3106613e04a9ab56b108ddbb19f4a.png" alt="49d3106613e04a9ab56b108ddbb19f4a.png"></p>
<p>浏览器在把这两个树进行合成渲染树的过程中会确定我们的节点是否可见，和各个节点的样式并精确他们的位置</p>
<p>这里可以看到，如果对一个元素使用了display：none，那么在渲染树中是不存在这个元素的。所以渲染树只包含可见节点</p>
<h2 id="二、回流"><a href="#二、回流" class="headerlink" title="二、回流"></a>二、回流</h2><p>当我们渲染树中的一些元素的结构或者尺寸等发生改变，浏览器重新渲染 部分或者全部文档的过程就叫做回流。</p>
<p><strong>会导致回流的操作：</strong></p>
<ol>
<li>页面首次渲染</li>
<li>浏览器窗口大小发生变化（如果是按照百分比布局的话，元素的宽度发生变化，就相当于尺寸发生变化，会引起回流）</li>
<li>内容变换 ，比如文本变化或图片被另一个不同尺寸的图片所替代</li>
<li>添加或者删除可见的节点</li>
<li>元素的位置发生变化</li>
<li>元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）</li>
</ol>
<p>…</p>
<h2 id="三、重绘"><a href="#三、重绘" class="headerlink" title="三、重绘"></a>三、重绘</h2><p>当页面中元素样式的改变不影响它在文档流中的位置，浏览器会将样式复制给元素，这个过程叫做重绘。</p>
<h2 id="四、如何减少回流、重绘"><a href="#四、如何减少回流、重绘" class="headerlink" title="四、如何减少回流、重绘"></a>四、如何减少回流、重绘</h2><ul>
<li><p>合并对DOM样式的修改，采用css class来修改</p>
  <div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>)再</span><br><span class="line">box.<span class="property">style</span>.<span class="property">margin</span> = <span class="string">&#x27;5px&#x27;</span></span><br><span class="line">box.<span class="property">style</span>.<span class="property">borderRadius</span> = <span class="string">&#x27;12px&#x27;</span></span><br><span class="line">box.<span class="property">style</span>.<span class="property">boxShadow</span> = <span class="string">&#x27;1px 3px 4px #ccc&#x27;</span></span><br></pre></td></tr></table></figure></div>
<p>  建议使用css class</p>
  <div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line">.<span class="property">active</span>&#123; </span><br><span class="line"> <span class="attr">margin</span>: 5px; </span><br><span class="line"> border-<span class="attr">dadius</span>: 12px; </span><br><span class="line"> box-<span class="attr">shadow</span>: 1px 3px 4px #ccc&#125;</span><br><span class="line"><span class="keyword">const</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>).<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;active&#x27;</span>)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>将DOM离线</p>
  <div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先为元素设置display：none操作结束后再把它显示出来。</span></span><br><span class="line"><span class="comment">//因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘，</span></span><br><span class="line"><span class="comment">//操作完之后再将display改为显示，只会触发一次回流与重绘</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> container = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;container&#x27;</span>)</span><br><span class="line">container.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span></span><br><span class="line">container.<span class="property">style</span>.<span class="property">width</span> = <span class="string">&#x27;100px&#x27;</span></span><br><span class="line">container.<span class="property">style</span>.<span class="property">height</span> = <span class="string">&#x27;200px&#x27;</span></span><br><span class="line">container.<span class="property">style</span>.<span class="property">border</span> = <span class="string">&#x27;10px solid red&#x27;</span></span><br><span class="line">container.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;red&#x27;</span></span><br><span class="line">...（省略了许多类似的后续操作）</span><br><span class="line">container.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;block&#x27;</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>当需要对多个DOM进行操作的时候，避免直接对单个DOM进行操作</p>
  <div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用 createDocumentFragment （创建文档碎片节点）方法创建虚拟的 dom 对象</span></span><br><span class="line"><span class="comment">// 这样的能将对 dom 的多次修改合并为一次，就能减少回流和重绘的次数</span></span><br><span class="line">    <span class="keyword">let</span> ul = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;ul&#x27;</span>)</span><br><span class="line">    <span class="keyword">let</span> box = <span class="variable language_">document</span>.<span class="title function_">createDocumentFragment</span>()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> li = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;li&quot;</span>)</span><br><span class="line">        li.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(i))</span><br><span class="line">        box.<span class="title function_">appendChild</span>(li)</span><br><span class="line">    &#125;</span><br><span class="line">    ul.<span class="title function_">appendChild</span>(box）</span><br><span class="line"><span class="comment">//createDocumentFragment使用appendChild追加子元素时，</span></span><br><span class="line"><span class="comment">//如果把它追加进页面中，则插入的是它本身和它的所有子孙节点</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局，如果一个表很大的话，浏览器会等全部渲染好在进行下一步，这个等待的过程会降低用户体验</p>
</li>
<li><p>尽可能不要修改影响范围比较大的 DOM，就是如果你要改变子元素的样式，就不要去它的父元素设置，不通过父元素去影响子元素，直接修改子元素。</p>
</li>
<li><p>动画实现速度的选择，动画速度越快，回流次数越多，也可以选择使用 <a class="link" href="https://juejin.cn/post/7147953172768620575">requestAnimationFrame<i class="fas fa-external-link-alt"></i></a>（请求动画帧），将不会进行重绘和回流</p>
</li>
</ul>
<p>…</p>
<p>总之：回流的性能消耗要比重绘大，能重绘就不回流，能不重绘就不重绘</p>
]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
</search>
